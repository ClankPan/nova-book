# Nova Book

## 1. 歴史的な背景、zkcashとかのゼロ知識から始まり、計算のオフロード化、外部委託

ゼロ知識証明というのは、その名の通り、「自分が持っている情報を明かさず、持っていることだけを証明する」技術の総称です。自分が隠したい情報を秘匿することが主な内容ですが、最近は計算量を圧縮することができる特性が注目されています。

ブロックチェーン上で何かを計算させると、その計算量に応じてとにかく支払うコストが莫大にかかります。そこで、少しでも計算量を減らしたいという動機が生まれ、この技術に注目と投資が集まるようになりました。これが近年急速にゼロ知識証明の研究が進んでいる理由です。


## 2. 計算量を減らすというのはどういうことか。

計算量を圧縮できるとはどういうことでしょうか。これは、問題を解く計算量と答えを検証する計算量が対応ではない、というありふれた問題として考えることができます。

たとえば、ソートを例に考えてみましょう。数字を順列に並び替えるには、最速でも $O(n\log{n})$ を必要とします。しかし、順列であることを確かめるだけだと、単純に考えても$O(n)$ だけです。つまり、100個の数字があるとすれば、ソートにはざっくり660回程度の計算が必要になりますが、確かめるには100回程度だけです。

このように、解く計算量よりも検証する計算の方が小さい、といった問題はありふれています。これをNP問題と呼びます。 

「自力で解を見つけるのは効率的にできるとは限らないが、いったん解を与えられれば、それが正しいかどうかは効率的に確かめられる」といった具合です。

## 3. 例えば、複雑な計算をソート問題へ帰着できればいい。

ではもし仮に、プログラムなどの計算をソート問題に置き換えることができるのなら、検証者は順列であるかを確かめるだけでプログラムが正しいことを検証できます。

つまり、(1) 計算をとある問題へ変換する、 (2) その問題の解を少ない計算量で検証してもらう、の二つに分けることができます。

実際にはプログラムをソート問題には置き換えることができないので、別の問題を使います。

## 4. ソートの代わりに、$f(x)=0$

先ほどの例で使ったソート問題の代わりに、シュワルツ・ジッペルの補題（Schwartz-Zippel lemma）とSumcheck（合計チェック）いうものを使います。これを使うと、$f(x)=0$ がどの $x$ に対しても成り立つことを、ランダムな点で $f(x)$ を一回だけ評価することで確かめることができます。

つまり、プログラムを $f(x)=0$ となるような $f$ に変換さえすることができれば、あとはこの問題の解を検証者に確かめさせるだけです。

シュワルツ・ジッペルの補題について少しだけ説明すると、二つの多項式をランダムな点で評価した結果が一致していれば、限りなく高い確率で2つは同じ多項式であると見なせるというものです。

中学や高校の数学の授業で、「二つの式が交わる点を求めよ」という問題を解いたことはないでしょうか。2つの式のグラフは、ほとんどの場所で重ならず、一点か二点だけでしか交わりません。なので、 $x$ を十分に大きな範囲からランダムに選べるのであれば、異なる式がその点で交わる確率はごく僅かで、この確率は実用上は無視することができます。

## 5. よく使われる表現方法、$a \times b = c$

プログラムを $f(x)=0$ となる多項式 $f$ に変換していくにはいくつかのステップが必要です。まずは計算を $a \times b = c$ の連なりで表現していきます。ルールとしては、a,b,cの項の中にはいくら足し算を入れもていいですが、掛け算は1行につき $a \times b$ の一回だけですので、もう一度掛け算が必要な場合は次の行に行ってください。

フィボナッチ数列なら次のようになります。aとbを足した結果がcとなり、次の行ではbとcが足されdとなっています。

$$
\begin{aligned}
(a + b) \times 1 &= c \\
(b + c) \times 1 &= d \\
(c + d) \times 1 &= e \\
(d + e) \times 1 &= f \\
\end{aligned}
$$

$ ax^3 + b x^2 + cx + d = e$ なら次のようになります。 $x^2$ と $x^3$ はそれ自体が $x$ の掛け算なので、$v,w$ に割り当ててあげて、$ax^3$ などは中間結果として $\alpha$ と置いてあげます。

$$
\begin{aligned}
x \times x &= v \\
x \times v &= w \\
a \times w &= \alpha \\
b \times v &= \beta \\
c \times x &= \gamma \\
(\alpha + \beta + \gamma + d) \times 1 &= e
\end{aligned}
$$

個の表現方法でプログラムのすべてを書き出すのは少々骨が折れる作業ですが、全くできないという程でもありません。今はこの形に変換するツールなどもあるので、それらを使えば好きなプログラムをこの形式に直すこともできます。

プログラムをこの形式に直すことができれば、あとはこの形式をどう、とある問題（ $f(x)=0$ など）に置き換えるかを考えればいいだけなので、割とよく出てくる中間表現です。

## 6. 行列でこれを表現する。

さて、プログラムを単純な形で表現することができましたが、これだけでは不十分です。なぜなら、$a,b,c,d,v,w,x,..$ などの変数は、文字的に同じ変数と見なしているだけで、それらが同じであるかを制約するものは何もないからです。

このような変数の使い回しを式で表現するには、行列の掛け算を使います。用意するのは、要素が $0,1$ で構成された $m \times n$ 行列 $A$ と、すべての変数が列挙された $n \times 1$ 行列 $Z$ です。すると、次のように、$Z$ から選ばれた変数の合計が結果となります。

$$
\begin{aligned}
A \cdot Z &=
\begin{bmatrix}
1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&=
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix} \\
\end{aligned}
$$

左の行列の中で、1になっている列番目が、対応する $Z$ の行番目になっていることがわかります。1行目では [1 1 0 0 ...] となっているので、 $Z$ の1行目と2行目の $a,b$ が選択され、行列の掛け算の規則により、それらが足された値が結果の行列の1行目の要素となっています。

$$
(1 \cdot a) + (1 \cdot b) + (0 \cdot c) + (0 \cdot d) + (0 \cdot e) + (0 \cdot f) + (0 \cdot 0) + (0 \cdot 1)
$$

これは、先ほどのフィボナッチ数列の $a \times b = c$ のうち、$a$ のすべての項の集合になっていることがわかります。 $b,c$ についても、次のように変数を選び、その和をとります。ただし、フィボナッチ数列では $a$ 以外では和を取らないので、ただ変数を選択しただけになっています。

$$

\begin{aligned}
B \cdot Z &=
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&=
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}\\
C \cdot Z &=
\begin{bmatrix}
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&=
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\

\end{aligned}
$$

最終的に、これを行列の式で表すと、次のようになります。 $\circ$ 記号は アダマール積（Hadamard Product）といって、重なり合う要素の掛け算だけをする演算記号です。普通の行列の掛け算は $\cdot$ 記号で表されます。

$$
\begin{aligned}
A \cdot Z \quad \circ \quad B \cdot Z  \quad &= \quad C \cdot Z  \\
\\
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix}
\quad
\circ
\quad
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}
\quad
&=
\quad
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\
\end{aligned}
$$

行列を使うことで、どの変数をどう使うかを表現することができました。この表現方法はR1CS（Rank-1 Constrain System）と呼ばれます。

## 7. まずは多項式にしよう。

行列式のままでは、掛け算などの手順が複雑なので、これを一旦次のような式に変形します。 $\sum$ は $i$ を0からN-1まで順番にあげていき、その和を取る演算記号です。上の行列式の $0$ 行目の計算と一致していることがわかると思います。

$$
\sum_{i=0}^N{A[0,i] \cdot Z[i]} \quad \cdot \quad \sum_{i=0}^N{B[0,i] \cdot Z[i]} \quad = \quad \sum_{i=0}^N{C[0,i] \cdot Z[i]}
$$

上の式では、$A[X,Y]$ でX行Y列の要素を取り出していますが、これは多項式の一部ではありません。なので、変数 $x$ によって同じように取り出せなくてはなりません。

$$
\begin{aligned}
f(x) = \sum_{i=0}^N{A(x,i) \cdot Z(i)} \quad \cdot \quad \sum_{i=0}^N{B(x,i) \cdot Z(i)} \quad - \quad \sum_{i=0}^N{C(x,i) \cdot Z(i)} = 0, \quad \{x | 0 \le x \lt N \}
\end{aligned}
$$

$A(x,y)$ などをどう作るかは置いておいて、$f(x)=0$ の形に近くなってきました。どんな $x$ とはいかずとも、0からN-1の区間なら0になります。

## 8. 行列の要素を取り出す多項式を考える。

$A(x,y)$ を作るにはどうしたらいいでしょうか？　まずは変数が1つの$Z(x)$ から考えてみることにします。

$[a,b,c,d,e,f,0,1]$ からn番目の要素を取り出すのは、先ほどの $\{0,1\}$ の行列で使ったテクニックを使います。つまり、取り出したい要素だけ1にして、それ以外は0にするという方法です。

$$
Z(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8) = (x_1 \cdot a) + (x_2 \cdot b) + (x_3 \cdot c) + (x_4 \cdot d) + (x_5 \cdot e) + (x_6 \cdot f) + (x_7 \cdot 0) + (x_8 \cdot 1)
$$

しかし、これでは変数の数が多い上に、2つ以上を選択してその合計値を取ってくることが出来てしまします。そこで、$Z$ への入力は $n$ を二進数で渡せるようにします。これだと、要素が8個ならば3つの変数だけでよく、さらに同時に1つの要素しか選択できません。

用意するのは、二つの二進数が一致すれば $1$ , 異なれば $0$ になる多項式です。これは次のように作ることができます。 $\prod$ は $i$ を増やしていって、その積をとる演算記号です。 $\sum$ の掛け算バージョンだと思ってください。

$$
eq((x_1, x_2, x_3), (y_1, y_2, y_3)) = \prod_{i=1}^4{(1-x_i)(1-y_i) + x_i y_i}
$$

3bitはここに書くのは長いので2bitにしますが、展開するとこのようになります。ビットが違う項はゼロになるので、一つでもゼロになれば掛け算によって結果もゼロになります。

$$
\begin{aligned}
eq((1,0), (1,0)) = \{(1-1)(1-1) + 1 \cdot 1 \} \cdot   \{(1-0)(1-0) + 0 \cdot 0 \} &= 1, \\
eq((0,1), (1,1)) = \{(1-0)(1-1) + 0 \cdot 1 \} \cdot   \{(1-1)(1-1) + 1 \cdot 1 \} &= 0, \\
\end{aligned}
$$

ということで、$eq$ を使うと、$Z$ は次のように書くことができます。 $X$ は $(x_1, x_2, x_3)$ のことです。

$$
\begin{aligned}
Z(X) &= a \cdot eq(X, (0,0,0)) + b \cdot eq(X, (0,0,1)) \\
&+ c \cdot eq(X, (0,1,0)) + d \cdot eq(X, (0,1,1)) \\
&+ e \cdot eq(X, (1,0,0)) + f \cdot eq(X, (1,0,1)) \\
&+ 0 \cdot eq(X, (1,1,0)) + 1 \cdot eq(X, (1,1,1))
\end{aligned}
$$

これを一般的定義にしてみましょう。 少し複雑なので順を追って説明していきます。 $y\in \{0,1\}^{\log N}$ を言葉にするなら、「Nをビットで表したときのすべてのパターン」です。$Z[X]$ は定数なので式を展開したときには実際の値が入ります。つまりこの式は、 $X$ と $y$ が一致するとき、それに対応する $Z$ の要素を取り出す、ということになります。

$$
Z(X) = \sum_{y\in \{0,1\}^{\log N}}{Z[X] \cdot eq(X, y)}
$$

$A,B,C$ も同じように定義することができます。ただし、行と列の二つを指定する必要があるので、それぞれの要素に対して $eq$ を二つかけてあげます。

$$
A(X_1, X_2) = \sum_{y_1\in \{0,1\}^{\log M}} \sum_{y_2\in \{0,1\}^{\log N}}{A[X_1, X_2] \cdot eq(X_1, y_1) \cdot eq(X_2, y_2)}
$$


このように、 $eq$ をベースに作った多項式は嬉しい性質があるので、他と区別できるようこれ以降は $\tilde{Z}(\cdot),\tilde{A}(\cdot),\tilde{B}(\cdot),\tilde{C}(\cdot)$ と表記しておきます。

## 9. 1つの多項式にまとめる。

定義した多項式を一つにまとめます。

$$
\begin{aligned}
&G(X) = \sum_{y\in \{0,1\}^{\log N}} \tilde{A}(X, y) \cdot \tilde{Z}(y) \quad \cdot \sum_{y\in \{0,1\}^{\log N}} \tilde{B}(X, y) \cdot \tilde{Z}(y) \quad - \sum_{y\in \{0,1\}^{\log N}} \tilde{C}(X, y) \cdot \tilde{Z}(y) = 0, \\
\\
&X \in \{0,1\}^{\log M}
\end{aligned}
$$

この $G$ は $X$ の全てのパターンで $G(X) = 0$ が成り立つはずです。もしどれか一つでも $0$ でなければ、それは不正な操作が行われ、 $a \times b = c$ のどこかが間違っているということになります。例えば、 $3 \times 2 = 5$ のような式が含まれているということです。

## 9. 行列の掛け算を多項式で表すにはどうしたいいか？まずは、ベクトルのn番目の要素を取り出す多項式を作ってあげる。

10. $x_i$ と $n_i$ が一致すれば1,異なれば0となる$ EQ_i(x_i,n_i)$ を用意して、全てのiに対して掛け合わせれば、XとNのビットが一致している時のみ1になる多項式EQ(X,N)を作れる。

11. 多項式 $EQ(X,N)$ に、N番目の要素 $vector[N]$ を係数としてかけてあげると、$f(X) = 11*EQ(X,N)$ は、XがNと同じ時は11、それ以外は0になる。

12. これを全てのベクトルの要素に対して行い、それらの和を取る式がそのベクトルのn番目の要素を取り出せる多項式である。　
$$
f(X) =\sum_{N \in \{0,1\}^{\log{n}}}vector[N]\cdot EQ(X,N)
$$ 
Xが(0,0)なら11、Xが(0,1)なら22、といった具合だ。

13. 行列に対しては、行番と列番が必要なので、XとYがMとNに一致する時のみ1になる $EQ(X,M)\cdot EQ(Y,N)$にM行N列の値を係数としてかけてあげればいい。 
$$
g(X, Y) =\sum_{M \in \{0,1\}^{\log{m}}}\sum_{N \in \{0,1\}^{\log{n}}}matrix[M,N]\cdot EQ(X,M)\cdot EQ(Y,N).
$$

14. では、さっきのA・zの計算を思い返してみると、Aの1行目と、zの重なる要素を掛け合わせ、その合計をとっていた。A(X,Y)が行列Aに対応する多項式で、Z(Y)がZに対応する多項式であるので、A(X,Y)*Z(Y)は、内部的にはこうなる。
$$
\begin{aligned}
AZ(X, Y) &= \sum_{M \in \{0,1\}^{\log{m}}}\sum_{N \in \{0,1\}^{\log{n}}}A[M,N] \cdot Z[N] \cdot EQ(X,M)\cdot EQ(Y,N) \\
\\
&= A[(0,0),(0,0)] \cdot Z[(0,0)] \cdot EQ(X,(0,0))\cdot EQ(Y,(0,0)) \\
&+ A[(0,0),(0,1)] \cdot Z[(0,1)] \cdot EQ(X,(0,0))\cdot EQ(Y,(0,1)) \\
&+ A[(0,0),(1,0)] \cdot Z[(1,0)] \cdot EQ(X,(0,0))\cdot EQ(Y,(1,0)) \\
&+ A[(0,0),(1,1)] \cdot Z[(1,1)] \cdot EQ(X,(0,0))\cdot EQ(Y,(1,1)) \\
&...
\end{aligned}
$$

15. つまり、AのM行N列目の要素と、zのN番目の要素をかけた値がAZ(X,Y)から出てくる。なので、A'(これはA・Z)のM番目を求めるには、$AZ(X,Y)$ のXをMで固定して、全てのYで計算した和を取ればいい。これは、 $A'(X)$ と一致するはず。Xは行数を表している。
$$
\sum_{N \in \{0,1\}^{\log{n}}}AZ(X, N) = A'(X)
$$

16. ということで、行列の $A \cdot Z \quad \odot \quad B \cdot Z = C \cdot Z$ は、次のような式に置き換えることができる。

$$
\sum_{N \in \{0,1\}^{\log{n}}}A(X,Y) \cdot Z(Y) \quad \cdot \sum_{N \in \{0,1\}^{\log{n}}}B(X,Y) \cdot Z(Y) \quad= \sum_{N \in \{0,1\}^{\log{n}}}C(X,Y) \cdot Z(Y)
$$

17. 右辺を左に持ってくれば、$f(X) = 0$ の形の多項式になるので、ここでようやくsumcheckを使える形に変形することができた。 $G(X) = 0$

18. sumcheckは、二つの多項式をランダムな点で評価した結果が一致していれば、その二つの多項式はかなりの確率で同じ多項式であるという前提に基づいている。この確率は十分なほどで、完全にランダムで選んだ点で一致するなら、実用上は同じ多項式とみなしても全く問題ない。ただし、その乱数を多項式を作る前に知ってしまっているのなら、そのような異なる二つの多項式を作ることは容易なので注意。

19. この性質を利用すると、sumcheckは、イメージとしては、f(x)をランダムな点で評価して0なら全ての他のxでも0になると見做せる、ということである。

20. しかし、先ほど作った $G(X)$ の $X$ は0と1の羅列なので、そのままランダムな点を入れるのは難しい。しかも、取りうる範囲が狭いので、十分な確率で検証することができない。たえば、Xが2bitだとすると4パターンしかないので、どれか1つだけ0になる多項式を作れば、25%の確率で通ってしまう。

21. そこで、Gの入力はそのままのbit列にしつつ、内部に乱数を係数として加えるとこの問題を回避することができる。単純に考えるならば、Gをxのすべてのパターンで0になるので、そこに乱数がかかっていてもすべて0である。さらに、この場合は、-1, 1のように互いを打ち消してしまうような不正なGも見抜くことができる。 $r_i$ が $x$ によって異なるようにすれば、たとえ $G(x_1) = -1$ , $G(x_2) = -1$ でも、$G(x_1) \cdot r_1 + G(x_2) \cdot r_2 \ne 0$ となるので、打ち消し合うことはない。

$$
\sum_{x \in \{0,1\}^{s}} G(x) \cdot r_i = 0
$$

22. $x$ によって変化する $r_i$ を作るには、 $eq(r, x)$ を使うことができる。$eq$ は今までは 0,1 にさせるために使ってきたが、eqに入る変数が0,1以外の場合は、0にならない関数として見ることができる。 $r_i$ が0になってしまうのは都合がわるい。

$$
Q(r) = \sum_{x \in \{0,1\}^{s}} G(x) \cdot eq(r, x)
$$

23. ということで、Qをランダムな点で評価した結果が0であれば、すべての点で評価しても0である可能性が非常に高い、ということになる。しかし、Qの中では結局Gをすべての点で評価してしまっているので、計算の削減になっていないことが問題である。

24. Q(x)を分解して、Q(r)を計算するよりも安くする。







--------
(*) 重要な定理を導入すると、「非零多項式には根（ゼロ点）が多くない」を利用することができる。
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="ClankPan" />
  <meta name="dcterms.date" content="2025-03-12" />
  <title>ゼロ知識証明を知りたい人のためのzkVM作成入門</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="./style.css" />
  <link rel="icon" type="image/png" href="./favicon.webp" />
  <link rel="icon" type="image/png" href="docs/favicon.webp" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">ゼロ知識証明を知りたい人のためのzkVM作成入門</h1>
<p class="author">ClankPan</p>
<p class="date">2025-03-12</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#はじめに" id="toc-はじめに">はじめに</a>
<ul>
<li><a href="#なぜzkvmなのか"
id="toc-なぜzkvmなのか">なぜzkVMなのか</a></li>
<li><a href="#zkvmのパラダイム"
id="toc-zkvmのパラダイム">zkVMのパラダイム</a></li>
<li><a href="#本書の想定する開発環境-執筆中"
id="toc-本書の想定する開発環境-執筆中">本書の想定する開発環境
<em>執筆中</em></a></li>
<li><a href="#著者について" id="toc-著者について">著者について</a></li>
</ul></li>
<li><a href="#ゼロ知識証明と計算圧縮"
id="toc-ゼロ知識証明と計算圧縮">ゼロ知識証明と計算圧縮</a>
<ul>
<li><a href="#解と検証の計算"
id="toc-解と検証の計算">解と検証の計算</a></li>
<li><a href="#シュワルツジッペルの補題"
id="toc-シュワルツジッペルの補題">シュワルツ・ジッペルの補題</a>
<ul>
<li><a href="#多項式とは" id="toc-多項式とは">多項式とは</a></li>
<li><a href="#多項式の一致" id="toc-多項式の一致">多項式の一致</a></li>
</ul></li>
<li><a href="#合計値での解の検証"
id="toc-合計値での解の検証">合計値での解の検証</a></li>
</ul></li>
<li><a href="#計算の記述" id="toc-計算の記述">計算の記述</a>
<ul>
<li><a href="#よく使われる計算の表現方法"
id="toc-よく使われる計算の表現方法">よく使われる計算の表現方法</a></li>
</ul></li>
<li><a href="#計算の変換" id="toc-計算の変換">計算の変換</a>
<ul>
<li><a href="#行列の式へ変換" id="toc-行列の式へ変換">行列の式へ変換</a>
<ul>
<li><a href="#行列とは" id="toc-行列とは">行列とは</a></li>
<li><a href="#行列の掛け算-執筆中"
id="toc-行列の掛け算-執筆中">行列の掛け算 <em>執筆中</em></a></li>
<li><a href="#変数の切り替え"
id="toc-変数の切り替え">変数の切り替え</a></li>
</ul></li>
<li><a href="#多項式への変換" id="toc-多項式への変換">多項式への変換</a>
<ul>
<li><a href="#全ての合計を求める記号-sum"
id="toc-全ての合計を求める記号-sum">全ての合計を求める記号 <span
class="math inline">\(\sum\)</span></a></li>
<li><a href="#要素を取り出す記号-mij"
id="toc-要素を取り出す記号-mij">要素を取り出す記号 <span
class="math inline">\(M[i,j]\)</span></a></li>
<li><a href="#制約式のおさらい"
id="toc-制約式のおさらい">制約式のおさらい</a></li>
<li><a href="#行列の積の-i-行目" id="toc-行列の積の-i-行目">行列の積の
<span class="math inline">\(i\)</span> 行目</a></li>
<li><a href="#行列の積を多項式で表現"
id="toc-行列の積を多項式で表現">行列の積を多項式で表現</a></li>
<li><a href="#要素を取り出す多項式-mxy"
id="toc-要素を取り出す多項式-mxy">要素を取り出す多項式 <span
class="math inline">\(M(x,y)\)</span></a></li>
<li><a href="#制約式を表す多項式"
id="toc-制約式を表す多項式">制約式を表す多項式</a></li>
<li><a href="#合計でもゼロ" id="toc-合計でもゼロ">合計でもゼロ</a></li>
<li><a href="#減らない検証コスト"
id="toc-減らない検証コスト">減らない検証コスト</a></li>
</ul></li>
<li><a href="#ここまでの見取り図-執筆中"
id="toc-ここまでの見取り図-執筆中">ここまでの見取り図
<em>執筆中</em></a></li>
</ul></li>
<li><a href="#計算の証明" id="toc-計算の証明">計算の証明</a>
<ul>
<li><a href="#サムチェック" id="toc-サムチェック">サムチェック</a></li>
<li><a href="#多項式コミットメント"
id="toc-多項式コミットメント">多項式コミットメント</a>
<ul>
<li><a href="#多項式の割り算"
id="toc-多項式の割り算">多項式の割り算</a></li>
<li><a href="#離散対数性" id="toc-離散対数性">離散対数性</a></li>
<li><a href="#検証" id="toc-検証">検証</a></li>
<li><a href="#コミットメント"
id="toc-コミットメント">コミットメント</a></li>
</ul></li>
<li><a href="#ランダムオラクル"
id="toc-ランダムオラクル">ランダム・オラクル</a>
<ul>
<li><a href="#ハッシュ関数-執筆中"
id="toc-ハッシュ関数-執筆中">ハッシュ関数 <em>執筆中</em></a></li>
</ul></li>
<li><a href="#楕円曲線と有限体-執筆中"
id="toc-楕円曲線と有限体-執筆中">楕円曲線と有限体
<em>執筆中</em></a></li>
<li><a href="#サムチェックプロトコル-執筆中"
id="toc-サムチェックプロトコル-執筆中">サムチェック・プロトコル
<em>執筆中</em></a></li>
<li><a href="#ここまでの見取り図-執筆中-1"
id="toc-ここまでの見取り図-執筆中-1">ここまでの見取り図
<em>執筆中</em></a></li>
</ul></li>
<li><a href="#計算の畳み込み-執筆中"
id="toc-計算の畳み込み-執筆中">計算の畳み込み <em>執筆中</em></a>
<ul>
<li><a href="#証明の再帰とは-執筆中"
id="toc-証明の再帰とは-執筆中">証明の再帰とは <em>執筆中</em></a></li>
<li><a href="#畳み込みとは-執筆中"
id="toc-畳み込みとは-執筆中">畳み込みとは <em>執筆中</em></a></li>
<li><a href="#hypernova-執筆中" id="toc-hypernova-執筆中">HyperNova
<em>執筆中</em></a>
<ul>
<li><a href="#多重線形多項式コミットメント-執筆中"
id="toc-多重線形多項式コミットメント-執筆中">多重線形多項式コミットメント
<em>執筆中</em></a></li>
<li><a href="#重のサムチェック-執筆中"
id="toc-重のサムチェック-執筆中">2重のサムチェック
<em>執筆中</em></a></li>
</ul></li>
</ul></li>
<li><a href="#zkvm-執筆中" id="toc-zkvm-執筆中">zkVM <em>執筆中</em></a>
<ul>
<li><a href="#cpuの役割-執筆中" id="toc-cpuの役割-執筆中">CPUの役割
<em>執筆中</em></a></li>
<li><a href="#命令の回路-執筆中"
id="toc-命令の回路-執筆中">命令の回路　<em>執筆中</em></a></li>
<li><a href="#オフラインメモリチェック-執筆中"
id="toc-オフラインメモリチェック-執筆中">オフライン・メモリ・チェック　<em>執筆中</em></a></li>
<li><a href="#nebula-執筆中" id="toc-nebula-執筆中">Nebula
<em>執筆中</em></a></li>
<li><a href="#スイッチボード-執筆中"
id="toc-スイッチボード-執筆中">スイッチ・ボード <em>執筆中</em></a></li>
<li><a href="#ビット演算-執筆中" id="toc-ビット演算-執筆中">ビット演算
<em>執筆中</em></a></li>
<li><a href="#浮動小数点数-執筆中"
id="toc-浮動小数点数-執筆中">浮動小数点数 <em>執筆中</em></a></li>
<li><a href="#実行トレース-執筆中"
id="toc-実行トレース-執筆中">実行トレース <em>執筆中</em></a></li>
<li><a href="#執筆中" id="toc-執筆中"><em>執筆中</em></a></li>
</ul></li>
</ul>
</nav>
<p><br> <br></p>
<hr />
<h1 id="はじめに">はじめに</h1>
<p><em>このオンラインブックは執筆中です。完成版ではありません。<a
href="https://docs.google.com/forms/d/e/1FAIpQLSd5NN8awATTEVN4kI_itnnJRNdEEgkoEnRFLuUaoxmLBgJZZQ/viewform?usp=header">フィードバック</a>
はこちらからお願いいたします。2025年6月の完成を目指しています。</em></p>
<p>本書では、アセンブリ言語にコンパイルされたプログラムの実行を証明する仮想マシン、つまりzkVMを作成を通して、ゼロ知識証明について学びます。</p>
<p>zkVMにはパラダイムがありますが、その中でも比較的理解しやすいものを選びました。本書だけではzkVMの全てを知ることはできませんが、ここで得られた知識はゼロ知識証明の世界に飛び込む読者の足がかりになるはずです。一見、難しそうに見える数式やコードが出てきますが、全てステップ・バイ・ステップで説明していきます。分からないと感じたらぜひ前の章に戻ってみてください。</p>
<p>この本では、理論と実装のパートが分かれています。もし、理論の途中でわからなくなってしまったら、再度上から読み直して、理解できるところまで実装してみてください。手を動かしてみると、より理解が深まりその先へと進めると思います。また、この時代はChatGPTのようなLLMに質問することも理解の手助けになると思いますので、ぜひ活用してみてください。</p>
<p>この本の読者は数学やプログラムが得意である必要はなく、むしろパズルの解き方を頭の中や紙の上で時間をかけて理解できれば十分です。なぜなら、私たちは新しい研究をするのではなく、すでに答えがある問いに対して、その解き方を理解できれば十分だからです。</p>
<p>また、本書の理解には必要ないが重要な概念や補足、こぼれ話はコラムとしてまとめていきますので、身構えず気楽に読み進めてください。</p>
<h3 id="なぜzkvmなのか">なぜzkVMなのか</h3>
<p>ゼロ知識証明を知るのに、なぜzkVMを題材に選んだのでしょうか？これは、近年のゼロ知識証明の研究が、どのようにzkVMを作るかという方向で活発化しているからです。そもそもVMとはVirtual
Machineのことで、仮想機械、つまりプログラム上でCPUなどのハードウェアをシミュレートし、さらにその上でプログラムを動かすという階層高構造になる仕組みのことです。ゼロ知識証明では複雑な計算を証明したいわけですが、基本的には証明のプロトコルによって書き方が異なります。</p>
<p>計算そのものをどう分かりやすく表現するかが問題になりますが、これにはいくつか方法があります。一つは専用の言語を作ってその言語でプログラムを直接書くことです。しかし、プログラマは既存のプログラムを専用言語でいちいち書き直したくないですし、ツールによって言語を使い分けることも認知的なコストが高くなりがちです。</p>
<p>一般的なプログラミング言語を専用言語に変換する、といった方法もありますが、プログラミング言語もバージョンによって書き方が微妙に異なりますし、全てに対して専用のコンパイラを用意するのもコストに見合うかわかりません。</p>
<p>そこで、既存のどのプログラミング言語からもコンパイルできて、変更が滅多に行われない言語、つまりアセンブリ言語そのものを証明してしまおう、ということです。アセンブリ言語で書かれた計算を証明するには、CPUそのもの挙動をゼロ知識証明のフォーマットで一度だけ定義し、どんなプログラムに対しても同じゼロ知識証明の回路を使い回せばいいのです。すると、プログラマも普段の業務と同じように好きな言語でプログラムを書き、自然とその計算が証明されるわけです。</p>
<figure>
<img src="figures/zkVMのレイヤー.drawio.svg" alt="レイヤー" />
<figcaption aria-hidden="true">レイヤー</figcaption>
</figure>
<h3 id="zkvmのパラダイム">zkVMのパラダイム</h3>
<p>zkVMはあくまでも「やりたいこと」であって、実際にどのような実装かを指す言葉ではありません。実装にはいくつかのパラダイムがあります。一つはプログラムの実行を一つの大きな証明回路にして、一度に証明しまう方式です。もう一つはプログラムの実行を小さなステップに分けて証明回路を繰り返し適用することで再帰的に証明する方式です。</p>
<p>前者をモノリシック（Monorithic）方式といい、後者をリカーシブ（Recursive）方式といいます。Monorithicで代表的なものはJolt/Lasso方式ですが、入門には難しすぎるので、比較的わかりやすいRecursiveのNova方式を本書では採用します。さらに、Novaの中でもわかりやすく今後の発展の基本となりそうなHyperNovaをベースに解説していきます。とくに、HyperNovaで使われる技術はJoltでも使われるものが多く、学ぶと他にも応用が効きます。</p>
<div class="note">
<p>コラム: ゼロ知識証明の回路</p>
<p>ゼロ知識証明の中でもSNARKという分野では、計算をひとまとまりにした単位を回路と呼びます。面白いことにzkVMは、CPUを二進数のANDやORの論理回路から、有限体のADDやMULの証明回路で書き直していく作業になります。ある意味でzkVMは、論理演算を使わない別の世界のコンピューターをいえるかもしれません。</p>
</div>
<div class="note">
<p>コラム: Novaの一族</p>
<p>Novaは高速なRecursive方式として、2021年ごろに登場しました。その後も改良が登場しましたが、それらの名前はオリジナルのNova（新星爆発）にちなんで付けられていきました。</p>
<p>最初に登場したのがSuperNova（超新星爆発）です。その後すぐにHyperNova（極超新星爆発）が提案され、さらにその後すぐに二つを組み合わせたSuperHyperNovaなんていうのも提案されかけました。</p>
<p>爆発のインフレーションはすぐに終わりましたが、現在でもNeutronNova（中性子新星爆発?）のような〇〇Novaという名称や、Nebula（星雲）や
ProtoStar（原始星）など宇宙にちなんだ名前が付けられています。</p>
<p>あなたのzkVMにも宇宙や星に関連する名前をつけてみるのも面白いかもしれません。</p>
</div>
<h3 id="本書の想定する開発環境-執筆中">本書の想定する開発環境
<em>執筆中</em></h3>
<h3 id="著者について">著者について</h3>
<p>ClankPan (<a href="https://x.com/ClankPan"><span class="citation"
data-cites="ClankPan">@ClankPan</span></a>)。NovaNet という zkVM
開発企業で働いており、仕事としては直接ゼロ知識証明に携わってはいないものの、個人的に勉強しながら業界の動向を追っています。</p>
<p>まだ黎明期にある zkVM
は、ゼロ知識証明の中でも特に注目されるトピックですが、網羅的に学べる日本語の解説はほとんどありません。そこで、私自身の勉強の過程で得た知見をまとめようと思い、この書籍の執筆を始めました。</p>
<p>書籍のフォーマットは私の尊敬する植山類さんの「<a
href="https://www.sigbus.info/compilerbook">低レイヤを知りたい人のためのCコンパイラ作成入門</a>」のフォーマットをお借りしました。</p>
<p>この書籍が、zkVM
やゼロ知識証明に興味を持った日本の皆さんの学習に少しでも役立てば幸いです。</p>
<p>また、本書の内容を題材とした勉強会や講演のご依頼なども歓迎します。興味のある方はお気軽にお声がけください。皆さんと学びを共有しながら、zkVM
やゼロ知識証明の面白さをより多くの方にお伝えできれば幸いです。</p>
<p><br></p>
<hr />
<h1 id="ゼロ知識証明と計算圧縮">ゼロ知識証明と計算圧縮</h1>
<p>ゼロ知識証明というのは、その名の通り、「自分が持っている情報を明かさず、持っていることだけを証明する」技術の総称です。自分が隠したい情報を秘匿することが主な内容ですが、最近は計算量を圧縮することができる特性が注目されています。</p>
<p>たとえば、ブロックチェーン上で何かを計算させると、その計算量に応じてとにかく支払うコストが莫大にかかります。そこで、少しでも計算量と通信を減らしたいという動機が生まれ、この技術に注目と投資が集まるようになりました。これが近年急速にゼロ知識証明の研究が進んでいる理由です。</p>
<div class="note">
<p>コラム: SNARK</p>
<p>情報を秘匿しなくてもいいから計算が正しいことを証明したい、という需要があります。これを他のゼロ知識証明と区別するため、SNARK（スナーク）と名付けられました。</p>
<p>サイズの証明が短く (succinct) 、やり取りが一度きり (non-interactive)
という意味です。さらに、ゼロ知識性がある場合はzkSNARKとZero
Knowledgeの頭文字であるzkを先頭につけます。</p>
</div>
<h2 id="解と検証の計算">解と検証の計算</h2>
<p>計算量を圧縮できるとはどういうことでしょうか。これは、問題を解く計算量と答えを検証する計算量が対等ではない、というありふれた問題として考えることができます。</p>
<p>たとえば、ソートを例に考えてみましょう。数字を順列に並び替える計算は、数列が順列であることを確かめるよりも多くの計算を必要とします。並び替え単純な方法は、最初の数字が右の数字よりも小さいかを比較して、大きければ入れ替える、という計算を全ての数字が満たすまで繰り返していきます。</p>
<p>一方で、数字が全て小さい順に並んでいるのを確かめるだけなら、左から順に数字を比較していくだけなので、数字の個数分の計算だけで済みます。つまり、100個の数字があるとすれば、ソートにはざっくり660回程度の計算が必要になりますが、確かめるには100回程度だけです。</p>
<p>このように、解く計算量よりも検証する計算の方が小さい、といった問題はありふれています。もし仮に、プログラムなどの計算をソートの解を求めることに置き換えることができるのなら、プログラムの計算が正しいかは、解が順列であるかを確かめるだけです。</p>
<figure>
<img src="figures/ソートの解と検証.drawio.svg" alt="　" />
<figcaption aria-hidden="true">　</figcaption>
</figure>
<p>ソートはあくまでも例えなので実際の証明には使いませんが、大きく分けて</p>
<ol type="1">
<li>計算をとある問題の解を求めることへ変換して証明、</li>
<li>その問題の解が正しいか検証してもらう、</li>
</ol>
<p>の二つに分けることができます。</p>
<figure>
<img src="figures/解と検証の計算.drawio.svg" alt="　" />
<figcaption aria-hidden="true">　</figcaption>
</figure>
<h2 id="シュワルツジッペルの補題">シュワルツ・ジッペルの補題</h2>
<p>ソートの例の代わりに、シュワルツ・ジッペルの補題（Schwartz-Zippel
lemma）とSumcheck（合計チェック）いうものを使います。この二つによって、証明者が出した解を、検証者がより少ない計算で検証することができます。</p>
<p>ではいったい、どんな計算を減らすことができるのでしょうか？
それは、式の合計を求める計算です。</p>
<p>シュワルツ・ジッペルの補題とサムチェックを使うことで、証明者は式の合計がとある値になることを伝え、検証がそれが成り立つかを簡単に確かめることができるのです。</p>
<h3 id="多項式とは">多項式とは</h3>
<p>まずは、多項式が何かについておさらいしていきましょう。多項式とはその名の通り、項（係数
<span class="math inline">\(\times\)</span>
変数）が式中に1つ以上存在する式のことです。たとえば次のような式で、係数
<span class="math inline">\(a,b,c\)</span> と変数 <span
class="math inline">\(x,y,z\)</span>
からの項がいくつかあることがわかると思います。これらの式はこれ以上、項を減らすことはできません。</p>
<p><span class="math display">\[
\begin{aligned}
f(x) &amp;= ax^2 + bx + c \\[0.8em]
g(x,y,x) &amp;= ax + by + cz \\
\end{aligned}
\]</span></p>
<h3 id="多項式の一致">多項式の一致</h3>
<p>シュワルツ・ジッペルの補題は、「
<em>二つの多項式の変数をランダムな値で評価したときに同じ結果になれば、二つが同じ多項式であると見なせる</em>
」といった定理です。中学や高校の数学の授業で、「二つの式が交わる点を求めよ」という問題を解いたことはないでしょうか？
2つのグラフは、ほとんどの場所で重ならず、一点か二点だけでしか交わりません。</p>
<figure>
<img src="figures/多項式の一致.gnuplot.svg" alt="　" />
<figcaption aria-hidden="true">　</figcaption>
</figure>
<p>2つの多項式をグラフにプロットしたときに、交わる点は全体の中では驚くほど少ないということです。なので、全く異なる多項式が、完全にランダムな点で交わる確率は極僅かになります。この確率は適切に設定すれば実用上無視できる確率になります。どれくらいかというと、地球上のすべての砂粒の中から、私がまいた砂の1粒を1回で選び出す確率よりも低くなります。</p>
<p>シュワルツ・ジッペルの補題は、ゼロ知識証明の中でも頻出なので、ぜひ押さえておきましょう。</p>
<h2 id="合計値での解の検証">合計値での解の検証</h2>
<p>証明者が特定の範囲では常に0になる多項式を見つけることができれば、検証者はその範囲の全ての値の合計も0であることを確かめれば良いのです。これにはサムチェックを使います。では、シュワルツ・ジッペルの補題はどこで出てくるかとういうと、サムチェックの中に出てきます。この辺りは後ほど解説しますので、身構えず読み進めてみてください。</p>
<div class="note">
<p>コラム: 計算量を表すオーダー</p>
<p>これを、オーダー（ <span class="math inline">\(O\)</span>
）という計算量を示す概念を導入して考えてみましょう。計算量は計算によって変化する個数
<span class="math inline">\(N\)</span>
が計算の中でどれだけ影響するかで表します。もし、<span
class="math inline">\(N\)</span>
の数字があって全ての数字を一度だけ見る計算なら、<span
class="math inline">\(O(N)\)</span>
となります。全ての数字に対して、全ての数字を掛け合わせる計算だとすれば、1つに対して
<span class="math inline">\(N\)</span> 回の計算が行われ、それが <span
class="math inline">\(N\)</span> 回繰り返されるので、<span
class="math inline">\(O(N \times N)\)</span> 、つまり、<span
class="math inline">\(O(N^2)\)</span> になります。</p>
<p>ソートには最速でも <span class="math inline">\(O(n\log{n})\)</span>
を必要とします。しかし、順列であることを確かめるだけだと、単純に考えても
<span class="math inline">\(O(n)\)</span> だけです。</p>
<p><span class="math inline">\(N\)</span>
が小さい時にはそれほど違いを感じませんが、 <span
class="math inline">\(N\)</span> が1,000や10,000
などになってくると計算回数にかなりの差が出てきます。</p>
<p>このように、大きな <span class="math inline">\(N\)</span>
に対してどれだけ違うか、をみる指標なので、 <span class="math inline">\(3
\times N\)</span> などの定数は無視して表記します。実際、大きな <span
class="math inline">\(N\)</span>
に対しては定数がかかっていてもそれほどの差は出ません。</p>
</div>
<div class="note">
<p>コラム: 式を評価？</p>
<p>多項式に限らず、式の変数に値で代入して結果を求めることを「評価」するといいます。この単語は英語由来のevaluationを直訳したものなので、日本語にすると少し不思議な感じがします。evaluationには値付けという意味があるので、式の値を求める述語としては少し納得できます。</p>
<p>どちらにしろ、数学の世界では評価という単語が使われていますので、計算する、くらいの意味として覚えておいてください。</p>
</div>
<p><br></p>
<hr />
<h1 id="計算の記述">計算の記述</h1>
<p>証明したい計算、つまりプログラム、を多項式の形で表現できれば、どうやら証明できそうなことが分かってきました。ここからは、計算をどう多項式に変換していくかについて考えていきます。プログラムを含めた色々な種類の計算のフォーマットの全てから直接多項式に変換する方法を考えるのは、非常にコストが高い作業になります。そこで、このような問題を解決するのによく用いられる手法が中間表現です。多様なフォーマットから変換しやすく、目的にフォーマットにも変換しやすい表現を中間に挟むことで、開発のコストを下げるという考え方です。</p>
<p>まずは、このような計算の記述方法についてみていきましょう。</p>
<figure>
<img src="figures/計算の記述.drawio.svg" alt="全体の流れ" />
<figcaption aria-hidden="true">全体の流れ</figcaption>
</figure>
<h2 id="よく使われる計算の表現方法">よく使われる計算の表現方法</h2>
<p>プログラムを多項式に変換していく前ステップとして、まずは計算を次のような制約式の連なりで表現していきます。</p>
<p><span class="math display">\[
\alpha \times \beta = \gamma
\]</span></p>
<p>ルールは、
それぞれの項の中にはいくら足し算を入れもていいですが、掛け算は1つの制約式につき一回だけですので、もう一度掛け算が必要な場合は次の式で行います。</p>
<p>たとえば、フィボナッチ数列なら次のようになります。aとbを足した結果がcとなり、次の行ではbとcが足されdとなっています。変数が同じなら、
<span class="math inline">\(1\times c = (a + b)\)</span>
でも構いません。</p>
<p><span class="math display">\[
\begin{aligned}
(a + b) \times 1 &amp;= c \\
(b + c) \times 1 &amp;= d \\
(c + d) \times 1 &amp;= e \\
(d + e) \times 1 &amp;= f \\
\end{aligned}
\]</span></p>
<p>変数に値を入れてみると、次のようになるはずです。この <span
class="math inline">\(a\)</span> から <span
class="math inline">\(f\)</span>
の値が計算の解となるわけです。簡単ですので、合っているか手で計算してみてください。</p>
<p><span class="math display">\[
a = 1, b = 2, c = 3,d = 5,e = 8,f = 13
\]</span></p>
<p><span class="math inline">\(ax^3 + b x^2 + cx + d = e\)</span>
なら次のようになります。 <span class="math inline">\(x^2\)</span> と
<span class="math inline">\(x^3\)</span> はそれ自体が <span
class="math inline">\(x\)</span> の掛け算なので、<span
class="math inline">\(v,w\)</span> に割り当ててあげて、<span
class="math inline">\(ax^3\)</span> などは中間結果として <span
class="math inline">\(\alpha\)</span> と置いてあげます。</p>
<p><span class="math display">\[
\begin{aligned}
x \times x &amp;= v \\
x \times v &amp;= w \\
a \times w &amp;= \alpha \\
b \times v &amp;= \beta \\
c \times x &amp;= \gamma \\
(\alpha + \beta + \gamma + d) \times 1 &amp;= e
\end{aligned}
\]</span></p>
<p>この表現方法でプログラムのすべてを書き出すのは少々骨が折れる作業ですが、全くできないという程でもありません。また、変換するツールなどもあるので、それらを使えば好きなプログラムをこの形式に直すこともできます。先ほど説明した専用言語やコンパイラのことです。</p>
<p>浮動小数点数やビット演算などの表現が難しいものは、別の技術を使ってカバーします。</p>
<div class="note">
<p>コラム: ルックアップ</p>
<p>ビット演算などの論理演算を、このような代数演算的な表現に落とし込むのはとても大変です。たとえば、変数が
<span class="math inline">\(0,1\)</span>
のどちらかであることを制約する式を考えてみましょう。次の式が成り立つのは
<span class="math inline">\(x\)</span> が <span
class="math inline">\(0,1\)</span> のときのみです。</p>
<p><span class="math display">\[
(1-x) \cdot x = 0
\]</span></p>
<p>このようにして、1つの変数に1つのビットを割り当てていくことができますが、32bitを表現するだけで30以上の制約式が必要となってしまいます。</p>
<p>このように、コンピュータ上で行われる全ての式を代数的な表現に置き換えることは証明コストの面から難しいため、通常は別の方法が使われます。それがルックアップです。</p>
<p>ビット演算などの計算に対して、あらかじめ答えが記録された表を作っておき、表に対して正しい入出力が行われたかだけを制約します。</p>
</div>
<div class="note">
<p>コラム: 中間表現 IR</p>
<p>中間表現のことを一般に IR（Intermediate
Representation）といいます。この用語はプログラミング言語の世界でよく使われるもので、様々なな言語から多様なCPUに対して言語を変換する際によく考えらます。特に、CPUの命令セットよって機械語が大きく異なるので、IRは必須です。もしIRがなければ、この世には「言語の種類
<span class="math inline">\(\times\)</span>
命令セットの種類」だけのコンパイラが生まれてしまいます。</p>
<p>一番有名なIRは、LLVMでしょう。LLVMは抽象的な命令セットで、ここから多くのアーキテクチャ向けに変換することが可能です。多くのプログラミング言語のコンパイラは、このLLVMのIR向けに言語を翻訳することで、多くのCPUへの対応をサポートしているのです。</p>
<p>現実の世界でも、英語がこのような役割を持つことがあります。</p>
<p><em>執筆中: 英語、機械翻訳の中間言語</em></p>
</div>
<p><br></p>
<hr />
<h1 id="計算の変換">計算の変換</h1>
<p>さて、プログラムを単純な形で表現することができましたので、次は証明できる形へ変換していきます。特に、<span
class="math inline">\(a,b,c,d,v,w,x,..\)</span>
などの変数は、文字的に同じ変数と見なしているだけで、それらが同じであるかを制約するものは何もありません。</p>
<figure>
<img src="figures/計算の変換.drawio.svg" alt="全体の流れ" />
<figcaption aria-hidden="true">全体の流れ</figcaption>
</figure>
<p>変数を束縛して、同じ変数をそれぞれの制約式で使われたものと同じであることを式として表現するには、行列の積を使います。行列の積を使えば綺麗に変数の束縛を表せるのですが、残念ながら私たちが使う証明には行列を使うことができません。そのため、行列の積をさらに多項式に変換してあげる必要があるのです。</p>
<figure>
<img src="figures/変換の流れ.drawio.svg" alt="変換の流れ" />
<figcaption aria-hidden="true">変換の流れ</figcaption>
</figure>
<h2 id="行列の式へ変換">行列の式へ変換</h2>
<p>このような変数の使い回しを式で表現するには、行列の掛け算を使います。まずは、行列について少し触れます。</p>
<h3 id="行列とは">行列とは</h3>
<p>行列と聞くと数学の難しい概念を想像してしまうかもしれません。しかし、実際には数字を縦と横に並べただけの表です。たとえば、これは、「2行
<span class="math inline">\(\times\)</span>
3列」の行列です。縦に2つ、横に3つの数字が並んでいます。</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \
\end{bmatrix}
\]</span></p>
<ul>
<li>行 (row): 横方向のまとまり</li>
<li>列 (column): 縦方向のまとまり</li>
</ul>
<p>上の例なら、1行目が <span class="math inline">\((1,2,3)\)</span>
、2行目が <span class="math inline">\((4,5,6)\)</span>
という感じですね。なぜ行列が必要だというと、情報を整理するための枠組みとして使います。身近な例として、エクセルでデータを整理するシーンを思い浮かべてみてください。「行
<span class="math inline">\(\times\)</span>
列」の表で、商品名や個数、単価などをまとめますよね。
あれとほぼ同じイメージで、行列は「数の表」として、データをわかりやすく並べることができるのです。</p>
<div class="note">
<p>コラム: マトリックス</p>
<p><em>執筆中: 映画, NVidia, 機械学習</em></p>
<p>行列は見た目が複雑で数字がたくさん並んでいるので、難しいように見えますが、やることは至ってシンプルです。</p>
<p>ではなぜ行列というものが存在するかというと、</p>
</div>
<h3 id="行列の掛け算-執筆中">行列の掛け算 <em>執筆中</em></h3>
<p>行列をただの表として捉えることもできますが、便利な演算のルールが用意されています。</p>
<figure>
<img src="figures/行列の積のルール.drawio.svg" alt="行列の積" />
<figcaption aria-hidden="true">行列の積</figcaption>
</figure>
<h3 id="変数の切り替え">変数の切り替え</h3>
<p>この行列の積を使って、 <span class="math inline">\(\alpha \times
\beta = \gamma\)</span> で表された制約式を変換していきます。</p>
<figure>
<img src="figures/変換の流れ、制約式から行列.drawio.svg"
alt="変換の流れ" />
<figcaption aria-hidden="true">変換の流れ</figcaption>
</figure>
<p>行列の積を使う理由は、「どの変数とどの変数を足し合わせるのか」を表現したいからでした。制約式の中では、
<span class="math inline">\(a,b,c...\)</span>
などの変数を使いますが、一つ目の制約式の <span
class="math inline">\(c\)</span> と二つの制約式の <span
class="math inline">\(c\)</span>
が同じものであるかを文字としてしか表現できていません。</p>
<p><span class="math display">\[
\begin{aligned}
(a + b) \times 1 &amp;= c \\
(b + c) \times 1 &amp;= d \\
(c + d) \times 1 &amp;= e \\
(d + e) \times 1 &amp;= f \\
\end{aligned}
\]</span></p>
<p>行列の掛け算をうまく利用すると、変数同士の足し算をうまく表現することができます。どの変数とどの変数を足し合わせるのか、これを先ほどのフィボナッチの例で見てみましょう。変数
<span class="math inline">\(a\)</span> と変数 <span
class="math inline">\(b\)</span> が足されています。</p>
<p><span class="math display">\[
(a + b) \times 1 = c
\]</span></p>
<p>まずは、計算に使われた変数 <span class="math inline">\(a\)</span>
から <span class="math inline">\(f\)</span>を全て列挙します。それを
<span class="math inline">\(0,1\)</span>
で構成された行列に掛けています。</p>
<p><span class="math display">\[
\begin{aligned}
\begin{bmatrix}
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
(a + b) \\
\end{bmatrix} \\
\end{aligned}
\]</span></p>
<p>1番目と2番目が <span class="math inline">\(1\)</span>
になっているので、<span class="math inline">\(a\)</span> と <span
class="math inline">\(b\)</span>
が選択され足されています。詳しく書くとこんな感じです。行列の掛け算の規則によって、うまいこと足し合わせたい変数だけが残ってることがわかると思います。</p>
<p><span class="math display">\[
(1 \cdot a) + (1 \cdot b) + (0 \cdot c) + (0 \cdot d) + (0 \cdot e) + (0
\cdot f) + (0 \cdot 0) + (0 \cdot 1)
\]</span></p>
<p>これを拡張して、要素が <span class="math inline">\(0,1\)</span>
で構成された <span class="math inline">\(m \times n\)</span> 行列 <span
class="math inline">\(A\)</span> と、すべての変数が列挙された <span
class="math inline">\(n \times 1\)</span> 行列 <span
class="math inline">\(Z\)</span>
を定義します。二つの行列を掛けると、</p>
<p><span class="math display">\[
\begin{aligned}
A \cdot Z &amp;=
\begin{bmatrix}
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix} \\
\end{aligned}
\]</span></p>
<p>フィボナッチ数列の制約式のうち、<span
class="math inline">\(\alpha\)</span>
のすべての項の集合になっていることがわかります。 <span
class="math inline">\(\beta , \gamma\)</span>
についても、次のように変数を選び、その和をとります。ただし、フィボナッチ数列では
<span class="math inline">\(\alpha\)</span>
以外では和を取らないので、ただ変数を選択しただけになっています。</p>
<p><span class="math display">\[
\begin{aligned}
B \cdot Z &amp;=
\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}\\
\\
C \cdot Z &amp;=
\begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\
\end{aligned} \\
\]</span></p>
<p>最終的に、行列の式で表すと、次のようになります。 <span
class="math inline">\(\circ\)</span> 記号は アダマール積（Hadamard
Product）といって、重なり合う要素の掛け算だけをする演算記号です。普通の行列の掛け算は
<span class="math inline">\(\cdot\)</span> 記号で表されます。</p>
<p><span class="math display">\[
\begin{aligned}
A \cdot Z \quad \circ \quad B \cdot Z  \quad &amp;= \quad C \cdot Z  \\
\\
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix}
\quad
\circ
\quad
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}
\quad
&amp;=
\quad
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\
\end{aligned}
\]</span></p>
<p>行列を使うことで、どの変数をどう使うかを表現することができました。この表現方法はR1CS（Rank-1
Constrain System）と呼ばれます。</p>
<div class="note">
<p>コラム: 中間表現の中間表現 CCS</p>
<p><em>執筆中: R1CS以外の中間表現, AIR, CCS</em></p>
</div>
<div class="note">
<p>コラム: 似て非なる、行列の式と行列式</p>
<p>一般的には「行列方程式 (matrix equation)」または「行列演算式 (matrix
expression)」と呼びます。</p>
<p>「行列式 (determinant)」 は、行列から
1つのスカラー値（数）を計算する別の概念で、縦棒 |..| で書かれます。</p>
<p><em>執筆中: </em></p>
</div>
<h2 id="多項式への変換">多項式への変換</h2>
<p>ここまでで、プログラムを制約式で表現し、さらに変数の束縛を行列の積で表現することができました。しかし、私たちが使う証明の方法では、行列の式を直接証明することができません。</p>
<figure>
<img src="figures/計算の変換.drawio.svg" alt="全体の流れ" />
<figcaption aria-hidden="true">全体の流れ</figcaption>
</figure>
<p>そこで、行列の積で表現した変数の束縛を変えずに、行列の積そのものを多項式で表現します。</p>
<figure>
<img src="figures/変換の流れ、行列から多項式.drawio.svg"
alt="変換の流れ" />
<figcaption aria-hidden="true">変換の流れ</figcaption>
</figure>
<p>まずは、行列の積のルールについておさらいしましょう。二つの行列をかけるには、左の行列の「行（縦）」と右の行列の「列（横）」の要素をかけて足します。</p>
<figure>
<img src="figures/行列の積のルール.drawio.svg" alt="行列の積のルール" />
<figcaption aria-hidden="true">行列の積のルール</figcaption>
</figure>
<p>行列の積の規則は複雑ですが、中身は掛け算の足し算のみですので、適切に分解してあげれば難しいことはありません。行列の
<span class="math inline">\(i\)</span> 行目 <span
class="math inline">\(j\)</span> 列目 を取り出す記号 <span
class="math inline">\([i,j]\)</span>
を使って、上の行列の掛け算を表してみると、次のようになります。</p>
<p><span class="math display">\[
M1 =
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
\end{bmatrix},
\quad
M1 =
\begin{bmatrix}
7 \\
8 \\
9
\end{bmatrix},
\quad
M3 =
\begin{bmatrix}
(1 \cdot 7) + (2 \cdot 8) + (3 \cdot 9) \\
(4 \cdot 7) + (5 \cdot 8) + (6 \cdot 9)
\end{bmatrix},
\]</span></p>
<p><span class="math display">\[
M3 =
\begin{bmatrix}
(M1[0,0] \cdot M2[0]) + (M1[0,1] \cdot M2[1]) + (M1[0,2] \cdot M2[2])
\\[0.8em]
(M1[1,0] \cdot M2[0]) + (M1[1,1] \cdot M2[1]) + (M1[1,2] \cdot M2[2])
\end{bmatrix},
\]</span></p>
<p>行列 <span class="math inline">\(M3\)</span> は、<span
class="math inline">\(M1, M2\)</span>
の要素の指定と、掛け算・足し算で表現できることがわかります。しかし、このような書き方は少し冗長ですので、合計の演算記号
<span class="math inline">\(\sum\)</span> を導入して記述してみます。</p>
<p><span class="math display">\[
M3 =
\begin{bmatrix}
\sum_{j=0}^{2}{M1[0, j] \cdot M2[j]} \\[0.8em]
\sum_{j=0}^{2}{M1[1, j] \cdot M2[j]}
\end{bmatrix}
\]</span></p>
<p>式の意味は、「 <span class="math inline">\(j\)</span> を <span
class="math inline">\(0\)</span> から <span
class="math inline">\(2\)</span>
まで変化させたときの要素の積の合計」となります。仮に、 <span
class="math inline">\(M3\)</span>
の最初の行だけを取り出すなら、このように書けばいいわけです。</p>
<p><span class="math display">\[
\sum_{j=0}^{2}{M1[0, j] \cdot M2[j]}
\]</span></p>
<p>証明で使えるような多項式に行列の積を変換する方向性が見えてきました。いくつか馴染みのない記号（<span
class="math inline">\(\sum\)</span> や <span
class="math inline">\([i,j]\)</span>
）が出てきたので、それらの使い方について軽く触れましょう。</p>
<h3 id="全ての合計を求める記号-sum">全ての合計を求める記号 <span
class="math inline">\(\sum\)</span></h3>
<p><span class="math inline">\(\sum\)</span>
の基本的な使い方は、「下に定義された変数を上に書かれた範囲まで順番に変化させていき、全てを足し合わせる」ように式を展開する記号です。例えば、
<span class="math inline">\(f(x)\)</span> を <span
class="math inline">\(1\)</span> から <span
class="math inline">\(3\)</span>
まで評価した時の合計を求める式を作りたければ、次のように書くことができます。</p>
<p><span class="math display">\[
f(1) + f(2) + f(3) \quad \rightarrow \quad  \sum_{i=1}^{3}{f(i)}
\]</span></p>
<h3 id="要素を取り出す記号-mij">要素を取り出す記号 <span
class="math inline">\(M[i,j]\)</span></h3>
<p><span class="math inline">\(M[i,j]\)</span> の使い方は、「行列 <span
class="math inline">\(M\)</span> の <span
class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span>
列の要素を取り出して置き換える」ように式を展開する記号です。例えば、
<span class="math inline">\(m \times n\)</span> サイズの行列 <span
class="math inline">\(M\)</span>
のすべての要素を足し合わせるのであれば、この記号 <span
class="math inline">\([i,j]\)</span> を使うと、次のようになります。</p>
<p><span class="math display">\[
M[0,0] + M[0,1] + ... + M[1,1] \quad \rightarrow \quad \sum_{i=0}^{m-1}
\; \sum_{j=0}^{n-1}{M[i,j]}
\]</span></p>
<h3 id="制約式のおさらい">制約式のおさらい</h3>
<p>行列の式を多項式に変換するのは、証明に適した形にしたいからでした。ここまでをいったん整理してみましょう。フィボナッチ数列の制約式は、次のような式でした。</p>
<p><span class="math display">\[
\begin{aligned}
(a + b) \times 1 &amp;= c \\
(b + c) \times 1 &amp;= d \\
(c + d) \times 1 &amp;= e \\
(d + e) \times 1 &amp;= f \\
\end{aligned}
\]</span></p>
<p>また、これを行列で表すとこうなります。行列を使う理由は、変数の束縛を表現できるからでした。</p>
<p><span class="math display">\[
(A \cdot Z ) \circ (B \cdot Z) = C \cdot Z
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\left(
\begin{bmatrix}
  1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
  \end{bmatrix}
  \cdot
  \begin{bmatrix}
  a \\
  b \\
  c \\
  d \\
  e \\
  f \\
  0 \\
  1 \\
  \end{bmatrix}
\right)
\circ
\left(
  \begin{bmatrix}
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
  \end{bmatrix}
  \cdot
  \begin{bmatrix}
  a \\
  b \\
  c \\
  d \\
  e \\
  f \\
  0 \\
  1 \\
  \end{bmatrix}
\right)
\\
\\ =
\left(
\begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
\right)
\end{aligned}
\]</span></p>
<h3 id="行列の積の-i-行目">行列の積の <span
class="math inline">\(i\)</span> 行目</h3>
<p>この式は、行列 <span class="math inline">\(A \cdot Z\)</span>
の結果の <span class="math inline">\(i\)</span>
行目の要素になります。</p>
<p><span class="math display">\[
\sum_{j=0}^{7}{A[i,j] \cdot Z[j]}
\]</span></p>
<p>では、<span class="math inline">\(0\)</span>
行目が実際にどうなるか一緒に式を展開してみましょう。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{j=0}^{7}{A[0,j] \cdot Z[j]} \\
\\
&amp; = A[0,0] \cdot Z[0] + A[0,1] \cdot Z[1] \\
&amp; + A[0,2] \cdot Z[2] + A[0,3] \cdot Z[3] \\
&amp; + A[0,4] \cdot Z[4] + A[0,5] \cdot Z[5] \\
&amp; + A[0,6] \cdot Z[6] + A[0,6] \cdot Z[6] \\
&amp; + A[0,7] \cdot Z[7] + A[0,8] \cdot Z[8] \\
\\
&amp;= (1 \cdot a) + (1 \cdot b) \\
&amp;+ (0 \cdot c) + (0 \cdot d) \\
&amp;+ (0 \cdot e) + (0 \cdot f) \\
&amp;+ (0 \cdot 0) + (0 \cdot 1) \\
\\
&amp;= a + b
\end{aligned}
\]</span></p>
<p>ここまでの、合計する記号 <span class="math inline">\(\sum\)</span>
と要素を取り出す記号 <span class="math inline">\(M[i,j]\)</span>
を使うと、行列の式の <span class="math inline">\(i\)</span>
行目の結果を表すことができるようになります。</p>
<p><span class="math display">\[
\sum_{j=0}^{7}{A[i,j] \cdot Z[j]} \quad \cdot \quad
\sum_{j=0}^{7}{B[i,j] \cdot Z[ij]} \quad = \quad \sum_{j=0}^{7}{C[i,j]
\cdot Z[j]}
\]</span></p>
<p>この式はつまり、 <span class="math inline">\(i\)</span>
行目の掛け算のことなので、 実際に <span
class="math inline">\(i=0\)</span>
で展開してみると、次が成り立つことがわかります。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{j=0}^{7}{A[0,j] \cdot Z[j]} \quad \cdot \quad
\sum_{j=0}^{7}{B[0,j] \cdot Z[ij]} \quad - \quad \sum_{j=0}^{7}{C[0,j]
\cdot Z[j]} \\[0.8em]
&amp;= (a + b) \cdot 1 - c \\[0.8em]
&amp;= 0
\end{aligned}
\]</span></p>
<p>お気づきかもしれませんが、 <span class="math inline">\(0\)</span>
行目のこの式は、フィボナッチ数列の
1つ目の制約式と一致しています。つまり、 <span
class="math inline">\(i\)</span> が <span
class="math inline">\(0\)</span> から <span
class="math inline">\(3\)</span>
のどれも、式はゼロとイコールになるのです。</p>
<p><span class="math display">\[
\begin{aligned}
(a + b) \times 1 &amp;- c = 0 \\
(b + c) \times 1 &amp;- d = 0 \\
(c + d) \times 1 &amp;- e = 0 \\
(d + e) \times 1 &amp;- f = 0 \\
\end{aligned}
\]</span></p>
<h3 id="行列の積を多項式で表現">行列の積を多項式で表現</h3>
<p>ここまでは、 <span class="math inline">\(i\)</span> 行 <span
class="math inline">\(j\)</span> 列の要素を取り出すのに、記号 <span
class="math inline">\([i,j]\)</span>
を使っていましたが、これは多項式ではありません。単に、式を展開するときに定数をどこから取ってくるかを指定しているにすぎません。</p>
<p>最終的な証明には、全てが多項式でなければならないので、記号 <span
class="math inline">\([i,j]\)</span>
も多項式で表されなければなりません。そこで、 <span
class="math inline">\(x\)</span> 行 <span
class="math inline">\(y\)</span> 列の要素を取り出す多項式 <span
class="math inline">\(A(x,y)\)</span> を考えます。</p>
<ul>
<li><span class="math inline">\(A[i,j]\)</span> :
「要素を取り出す記号」</li>
<li><span class="math inline">\(A(x,y)\)</span> :
「要素を取り出す多項式」</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;f(x) = \sum_{y=0}^{7}{A(x,y) \cdot Z(y)} \quad \cdot \quad
\sum_{y=0}^{7}{B(x,y) \cdot Z(y)} \quad - \quad \sum_{y=0}^{7}{C(x,y)
\cdot Z(y)}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(A(x,y)\)</span>
などをどう作るかは置いておいて、<span
class="math inline">\(f(x)=0\)</span>
の形に近くなってきました。この式は、<span
class="math inline">\(0\)</span> から <span
class="math inline">\(4\)</span> の区間なら <span
class="math inline">\(f(x)\)</span>
がゼロになります。証明を行うサムチェックは、ある区間の合計が0になることを証明できるので、最終的にこの形に持っていければよさそうです。計算を多項式へと変換する工程もいよいよ最後の段階になりました。</p>
<figure>
<img src="figures/変換の流れ、行列の積を多項式で.drawio.svg"
alt="変換の流れ" />
<figcaption aria-hidden="true">変換の流れ</figcaption>
</figure>
<h3 id="要素を取り出す多項式-mxy">要素を取り出す多項式 <span
class="math inline">\(M(x,y)\)</span></h3>
<p><span class="math inline">\(A(x,y)\)</span>
を作るにはどうしたらいいでしょうか？　まずは変数が1つの<span
class="math inline">\(Z(x)\)</span> から考えてみることにします。</p>
<p><span class="math inline">\(Z\)</span> 、つまり <span
class="math inline">\([a,b,c,d,e,f,0,1]\)</span>
からn番目の要素を取り出すのは、先ほどの <span
class="math inline">\(\{0,1\}\)</span>
を掛け合わせるテクニックを使います。取り出したい要素だけ1にして、それ以外は0にするという方法です。</p>
<p><span class="math display">\[
\begin{aligned}
Z(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8) &amp;= (x_1 \cdot a) + (x_2
\cdot b) \\
&amp;+ (x_3 \cdot c) + (x_4 \cdot d) \\
&amp;+ (x_5 \cdot e) + (x_6 \cdot f) \\
&amp;+ (x_7 \cdot 0) + (x_8 \cdot 1)
\end{aligned}
\]</span></p>
<p>使い方は、3番目の要素を取り出したければ、3つ目の変数のみを <span
class="math inline">\(1\)</span> にすればいいのです。</p>
<p><span class="math display">\[
Z(0,0,1,0,0,0,0,0) = c
\]</span></p>
<p>しかし、これでは変数の数が多い上に、2つ以上を選択してその合計値を取ってくることが出来てしまします。そこで、<span
class="math inline">\(Z\)</span> の <span
class="math inline">\(n\)</span>
番目の要素を指定するのに、二進数で渡せるようにします。これだと、要素が8個ならば3つの変数だけでよく、さらに同時に1つの要素しか選択できません。この二進数をうまいこと
<span class="math inline">\({0,1}\)</span>
となる係数に変換できればいいのです。</p>
<p>3は二進数では <span class="math inline">\(0b011\)</span>
ですので、このような感じで3つ目の要素を指定できれば、いいわけです。</p>
<p><span class="math display">\[
Z(0,1,1) = c
\]</span></p>
<p>用意するのは、2つの二進数が一致すれば <span
class="math inline">\(1\)</span> , 異なれば <span
class="math inline">\(0\)</span>
になる多項式です。これは次のように作ることができます。 <span
class="math inline">\(\prod\)</span> は <span
class="math inline">\(i\)</span>
を増やしていって、その積をとる演算記号です。 <span
class="math inline">\(\sum\)</span>
の掛け算バージョンだと思ってください。</p>
<p><span class="math display">\[
eq((x_1, x_2, x_3), (y_1, y_2, y_3)) = \prod_{i=1}^3{(1-x_i)(1-y_i) +
x_i y_i}
\]</span></p>
<p>3bitはここに書くのは長いので2bitにしますが、展開するとこのようになります。ビットが違う項はゼロになるので、一つでもゼロになれば掛け算によって結果もゼロになります。</p>
<p><span class="math display">\[
\begin{aligned}
eq((1,0), (1,0)) = \{(1-1)(1-1) + 1 \cdot 1 \} \cdot   \{(1-0)(1-0) + 0
\cdot 0 \} &amp;= 1, \\[0.8em]
eq((0,1), (1,1)) = \{(1-0)(1-1) + 0 \cdot 1 \} \cdot   \{(1-1)(1-1) + 1
\cdot 1 \} &amp;= 0, \\
\end{aligned}
\]</span></p>
<p>ということで <span class="math inline">\(eq\)</span> を使えば、 <span
class="math inline">\(Z\)</span>
は次のように書くことができます。式の中に <span
class="math inline">\((x_1, x_2, x_3)\)</span> を毎回書くのは大変なので
<span class="math inline">\(X\)</span>
としていますが、同じものです。</p>
<p><span class="math display">\[
\begin{aligned}
Z(X) &amp;= a \cdot eq(X, (0,0,0)) + b \cdot eq(X, (0,0,1)) \\[0.8em]
&amp;+ c \cdot eq(X, (0,1,0)) + d \cdot eq(X, (0,1,1)) \\[0.8em]
&amp;+ e \cdot eq(X, (1,0,0)) + f \cdot eq(X, (1,0,1)) \\[0.8em]
&amp;+ 0 \cdot eq(X, (1,1,0)) + 1 \cdot eq(X, (1,1,1))
\end{aligned}
\]</span></p>
<p>これを定義にしてみましょう。
少し複雑なので順を追って説明していきます。 <span
class="math inline">\(y\in \{0,1\}^{\log N}\)</span>
は言葉にするなら、「Nをビットで表したときのすべてのパターン」です。<span
class="math inline">\(Z[X]\)</span>
は定数なので式を展開したときには実際の値が入ります。つまりこの式は、
<span class="math inline">\(X\)</span> と <span
class="math inline">\(y\)</span> のビットが一致するとき、それに対応する
<span class="math inline">\(Z\)</span>
の要素を取り出す、ということになります。</p>
<p><span class="math display">\[
Z(X) = \sum_{y\in \{0,1\}^{\log N}}{Z[X] \cdot eq(X, y)}
\]</span></p>
<p>例えば、このようになります。</p>
<p><span class="math display">\[
\begin{aligned}
Z((0,0,0)) &amp;= a, \\[0.8em]
Z((0,0,1)) &amp;= b, \\[0.8em]
Z((0,1,0)) &amp;= c, \\[0.8em]
\end{aligned}
\]</span></p>
<p><span class="math inline">\(A,B,C\)</span>
も同じように定義することができまが、行と列の二つを指定する必要があるので、それぞれの要素に対して
<span class="math inline">\(eq\)</span> を二つかけてあげます。</p>
<p><span class="math display">\[
A(X_1, X_2) = \sum_{y_1\in \{0,1\}^{\log M}} \sum_{y_2\in \{0,1\}^{\log
N}}{A[X_1, X_2] \cdot eq(X_1, y_1) \cdot eq(X_2, y_2)}
\]</span></p>
<p><span class="math inline">\(eq\)</span>
をベースに作った多項式は嬉しい性質があるので、他と区別できるようこれ以降は
<span
class="math inline">\(\tilde{Z}(\cdot),\tilde{A}(\cdot),\tilde{B}(\cdot),\tilde{C}(\cdot)\)</span>
と表記しておきます。</p>
<div class="note">
<p>コラム: 多重線形拡張 MLE</p>
<p><span class="math inline">\(eq(x,y)\)</span>
をベースに作った多項式のことを MLE (Multi Linear
Extension（多重線形拡張）)といいます。</p>
<p><em>執筆中</em></p>
</div>
<h3 id="制約式を表す多項式">制約式を表す多項式</h3>
<p>定義した多項式を一つにまとめます。</p>
<p><span class="math display">\[
\begin{aligned}
G(X) &amp;= \sum_{y\in \{0,1\}^{\log N}} \tilde{A}(X, y) \cdot
\tilde{Z}(y)
\cdot \sum_{y\in \{0,1\}^{\log N}} \tilde{B}(X, y) \cdot \tilde{Z}(y)
- \sum_{y\in \{0,1\}^{\log N}} \tilde{C}(X, y) \cdot \tilde{Z}(y) \\
\\
&amp;X \in \{0,1\}^{\log M}
\end{aligned}
\]</span></p>
<p>この <span class="math inline">\(G\)</span> は <span
class="math inline">\(X\)</span> の全てのパターンで <span
class="math inline">\(G(X) = 0\)</span>
が成り立つはずです。もしどれか一つでも <span
class="math inline">\(0\)</span> でなければ、それは不正な操作が行われ、
<span class="math inline">\(a \times b = c\)</span>
のどこかが間違っているということになります。例えば、 <span
class="math inline">\(3 \times 2 = 5\)</span>
のような式が含まれているということです。</p>
<p>行列の行数 <span class="math inline">\(M = 4\)</span>
なら変数は2つで、次のようになります。</p>
<p><span class="math display">\[
G((0,0)) = G((0,1)) = G((1,0)) = G((1,1)) = 0
\]</span></p>
<h3 id="合計でもゼロ">合計でもゼロ</h3>
<p>全て <span class="math inline">\(0\)</span> になるのなら、合計も
<span class="math inline">\(0\)</span>
であるはずなので、一つの式にまとめることができます。 <span
class="math display">\[
\sum_{y\in \{0,1\}^{\log M}} G(y) = 0
\]</span></p>
<p>しかし、例えば、<span class="math inline">\(G((0,0)) = 1, G((0,1)) =
-1\)</span> だとすると、お互いを打ち消してしまい、合計として <span
class="math inline">\(0\)</span> になることを防げません。</p>
<p>そこで、<span class="math inline">\(G\)</span>
にランダムな係数をかけて、打消し合う可能性を小さくするという発想が考えられます。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{y\in \{0,1\}^{\log M}} r_i \cdot G(y) \\[0.8em]
\\
&amp;= r_1 \cdot G((0,0)) + r_2 \cdot G((0,1)) + r_3 \cdot G((1,0)) +
r_4 \cdot G((1,1)) \\[0.8em]
&amp;= 1 \cdot r_1 + (-1) \cdot r_2 + 0 \cdot r_3 + 0 \cdot r_4\\[0.8em]
&amp;\ne 0
\end{aligned}
\]</span></p>
<p>だだし、これでは変数がなく、多項式ではなくなってしまうので、次のようにしてあげることで、多項式のままにすることができます。</p>
<p><span class="math display">\[
\tilde{Q}(\beta) = \sum_{y\in \{0,1\}^{\log M}} G(y) \cdot eq(y, \beta)
= 0
\]</span> 式を見ると、<span class="math inline">\(G\)</span>
にかかるランダムな係数が、<span class="math inline">\(eq(y,
\beta)\)</span> によって変化していくことがわかります。ランダムな値 <span
class="math inline">\(\beta\)</span> が <span
class="math inline">\(\{0,1\}^s\)</span> でない限りは、 <span
class="math inline">\(eq\)</span> がゼロになることはありません。なので、
<span class="math inline">\(eq\)</span>
はランダムな変数によって係数が変わり、さらにそれ自体が0にならない、という嬉しい性質があるのです。</p>
<p>例えば、<span class="math inline">\(\beta = (11, 22)\)</span>
ならば、次のように展開できます。</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{Q}((11, 22)) &amp;= G((0,0)) \cdot (1-11) \cdot (1-22) \\[0.8em]
&amp;+ G((0,1)) \cdot  (1-11) \cdot 22 \\[0.8em]
&amp;+ G((1,0)) \cdot  11 \cdot (1-22) \\[0.8em]
&amp;+ G((1,1)) \cdot  11\cdot 22 \\
\end{aligned}
\]</span></p>
<h3 id="減らない検証コスト">減らない検証コスト</h3>
<p><span class="math inline">\(\tilde{Q}\)</span>
を展開してみるとわかるのですが、<span class="math inline">\(G\)</span>
がゼロになるので、<span class="math inline">\(f(x) = 0 \cdot x_1 + 0
\cdot x_2\)</span> のような、全ての項の係数が <span
class="math inline">\(0\)</span>
となるゼロ多項式となってしまいます。これでは、この多項式を渡された検証者が、何を検証していいか分からず、式の正当性を確かめられません。
<span class="math inline">\(G\)</span> が 本当に <span
class="math inline">\(0\)</span> であるかを確かめてもうらうには、<span
class="math inline">\(G\)</span>
の変数を残さなくてはいけないのです。</p>
<p>そこで、<span class="math inline">\(Q(\beta)\)</span>
から合計する前の項を取り出し、 <span class="math inline">\(g(X)\)</span>
とします。検証者には、この <span class="math inline">\(g\)</span> が
<span class="math inline">\(\{0,1\}^s\)</span> の全てで <span
class="math inline">\(0\)</span>
になることを確かめてもらうことで、計算が正しかったと検証してもらいます。</p>
<p><span class="math display">\[
g(X) =  G(X) \cdot eq(X, \beta)
\]</span></p>
<p>検証者に直接 <span class="math inline">\(g(X)\)</span>
を渡して、全パターンを試してもらうこともできますが、それでは計算が減るどころか少し増えてしまいます。</p>
<p>ここで使えるのが、sumcheck protocol
です。検証者が全パターンを試すよりも少ないコストで、全てのパターンが
<span class="math inline">\(0\)</span>
であることを証明することができす。</p>
<h2 id="ここまでの見取り図-執筆中">ここまでの見取り図
<em>執筆中</em></h2>
<p><br></p>
<hr />
<h1 id="計算の証明">計算の証明</h1>
<p>いよいよ登場しました、Sumcheck Protocol です。
仕組みを言葉で表現するならば、「変数が1つの多項式に分解し、それぞれが同じ多変数多項式がベースであることをランダムな点で検証してもらう。」です。</p>
<p>多変数多項式とは、 <span class="math inline">\(f(x,y,z) = ax + by +
cz\)</span> のような変数が複数ある式で、1変数多項式とは <span
class="math inline">\(h(x) = ax + b\)</span>
のような変数が一つだけの式の事です。では、なぜ変数ごとに式を分けると計算量が減るかを考えてみましょう。</p>
<p>単純に考えると、3変数多項式なら、<span
class="math inline">\(f\)</span>
の中の3つの変数の評価を8パターンで試すので、<span
class="math inline">\(3 \times 2^3 = 24\)</span>
の計算が必要になります。
一方で、3変数多項式を3つの1変数多項式に分解すると、変数を評価は同じく8パターンですが、式中の変数は1つだけなので、
<span class="math inline">\(1 \times 2^3 = 8\)</span> となります。</p>
<p>Sumcheck Protocol では1つの式ごとに3回の評価が必要なだけなので、
<span class="math inline">\(O(N)\)</span>
ですが、全パターンを評価するのは <span class="math inline">\(O(N \cdot
2^N)\)</span> となります。</p>
<p>このように、検証者の評価の回数を減らしつつ、適切に元の多変数多項式が分けられているのかを証明するのがこの
Sumcheck Protocolの肝なのです。</p>
<figure>
<img src="figures/計算の証明.drawio.svg" alt="全体の流れ" />
<figcaption aria-hidden="true">全体の流れ</figcaption>
</figure>
<p>さらに、サムチェック・プロトコルを使った証明の中にもいくつかのステップがあります。これら三つの証明を組み合わせることで、全体の証明がなされます。今回はサムチェックを使っていますが、このような構成はよくあるので、ぜひ覚えておきましょう。</p>
<figure>
<img src="figures/証明の流れ.drawio.svg" alt="証明の流れ" />
<figcaption aria-hidden="true">証明の流れ</figcaption>
</figure>
<div class="note">
<p>コラム: プロトコル</p>
<p><em>執筆中:　馴染みのない用語 protocol</em></p>
</div>
<h2 id="サムチェック">サムチェック</h2>
<p>ではまず、多変数から1変数への変換方法を考えます。ここでは <span
class="math inline">\(g(X)\)</span> を取り扱いたいので、ひとまず、 <span
class="math inline">\(X = (x_1, x_2)\)</span> としておきます。
検証者には次の3つの多項式と使用したランダムな3つの値 <span
class="math inline">\(r1, \beta_1, \beta_2\)</span> を渡します。この
<span class="math inline">\(r1\)</span>
は検証者から最初にもらったり、改竄できない形で証明者が生成したりします。</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
\quad &amp;g((x_1, x_2)) =  G((x_1, x_2)) \cdot eq((x_1, x_2), (\beta_1,
\beta_2)), \\
\\
\quad &amp;g_1(x_1) = \sum_{y \in \{0,1\}}{g((x_1, y))} = g((x_1, 0)) +
g((x_1, 1)), \\
\\
\quad &amp;g_2(x_2) = g((r_1, x_2)), \\
\end{aligned}
\right.
\]</span></p>
<p>検証者は、<span class="math inline">\(g(X)\)</span>
が全てのパターンで <span class="math inline">\(0\)</span> になることを
<span class="math inline">\(g_1, g_2\)</span>
を使って確かめていきます。まず、<span
class="math inline">\(g_1(x)\)</span> を使って、<span
class="math inline">\(G(X)\)</span> がどのパターンでも <span
class="math inline">\(0\)</span>
であるという主張を確かめます。この時点では <span
class="math inline">\(g_1(x)\)</span> が　<span
class="math inline">\(G(X)\)</span>
を元に作られているかはまだ検証できていませんが、ひとまず <span
class="math inline">\(G(X)\)</span>
がゼロになりそうなことは分かりました。</p>
<p><span class="math display">\[
g_1(0) = g_1(1) = 0
\]</span></p>
<p>なので検証者は、本当に <span class="math inline">\(g_1(x)\)</span> が
<span class="math inline">\(G(X)\)</span> の <span
class="math inline">\(x_2\)</span> を <span
class="math inline">\(0\)</span> と <span
class="math inline">\(1\)</span>
で評価した多項式であるかを確かめなければなりません。方針は、シュワルツ・ジッペルの補題
を使って、ランダムな点で評価して同じ多項式は同じと見なせる、という性質を使います。つまり、<span
class="math inline">\(g_1(x)\)</span> と <span
class="math inline">\(G(X)\)</span> を <span
class="math inline">\(x_1,x_2\)</span> を <span
class="math inline">\(r_1,r_2\)</span>
で評価してその結果を比べるということです。</p>
<p>しかし、<span class="math inline">\(g_1(x)\)</span> の内部の <span
class="math inline">\(x_2\)</span> はすでに <span
class="math inline">\(0,1\)</span> で評価されてしまっているので、<span
class="math inline">\(g_2(x)\)</span> を代わりに使います。まずは、<span
class="math inline">\(g_1(x)\)</span> と <span
class="math inline">\(g_2(x)\)</span>
が同じ多項式であるかを確かめましょう。ちなみに、この時点で <span
class="math inline">\(g_1, g_2\)</span> の内部で本当に <span
class="math inline">\(g\)</span> が使われているか分からないので、<span
class="math inline">\(g\)</span> の代わりに <span
class="math inline">\(s, s&#39;\)</span> をおいておきます。</p>
<p><span class="math display">\[
\begin{aligned}
g_1(r_1) &amp;= g_2(0) + g_2(1) \\
\\
\sum_{y \in \{0,1\}}{s((r_1, y))} &amp;= s&#39;((r_1, 0)) + s&#39;((r_1,
1))
\end{aligned}
\]</span></p>
<p><span class="math inline">\(g_1, g_2\)</span> がどうやら同じ多項式
<span class="math inline">\(s\)</span>
を元に作られたということは確かめられました。そして、<span
class="math inline">\(g_2\)</span> を使うことで、<span
class="math inline">\(G(X)\)</span>
と同じ多項式であるかも確かめることができます。これには、 <span
class="math inline">\(G\)</span> を <span class="math inline">\(r_1,
r_2\)</span> で評価し、その結果を <span
class="math inline">\(g_2\)</span> を <span
class="math inline">\(r_2\)</span>
で評価した結果と比べます。すると、<span
class="math inline">\(g_2\)</span> の内部にある <span
class="math inline">\(x_1\)</span> は既に <span
class="math inline">\(r_1\)</span>
で評価されているので、同じランダムな点で二つの多項式を評価し比較することができるのです。</p>
<p><span class="math display">\[
\begin{aligned}
G((r_1, r_2))  &amp;= g_2(r_2) \\
\\
&amp;= s((r_1, r_2)) \\
\end{aligned}
\]</span></p>
<p>二つが同じ値になるなら、<span class="math inline">\(g_1\)</span>
の内部で使われている多項式 <span class="math inline">\(s\)</span> は
<span class="math inline">\(G\)</span> と同じなので、<span
class="math inline">\(g_1(0) = g_1(1) = 0\)</span>
によって、全てのパターンで <span class="math inline">\(G\)</span>
がゼロであることも検証できました。</p>
<p>ここまでは <span class="math inline">\(X\)</span>
の変数が2つでしたが、3つ以上の場合には</p>
<p><span class="math display">\[
\begin{aligned}
g_2(r2) &amp;= g_3(0) + g_3(1), \\
g_3(r3) &amp;=  g_4(0) + g_4(1), \\
...
\end{aligned}
\]</span></p>
<p>と検証しいき、<span class="math inline">\(G((r_1, r_2,.., r_n)) =
g_n(r_n)\)</span> となることを確かめます。</p>
<h2 id="多項式コミットメント">多項式コミットメント</h2>
<p>1変数多項式とシュワルツ・ジッペルの補題によって、少ない計算回数によって合計が計算できることが分かりました。しかし、多項式コミットメントを使うと、これよりもまだ検証者の計算を減らすことができます。今の状態では、検証者は証明者から
<span class="math inline">\(g_1,g_2,...\)</span>
を受け取って、それぞれを乱数 <span class="math inline">\(r_i\)</span>
で評価しなければなりません。多項式コミットメントは、この操作を減らすことができるのです。具体的には、証明者が計算した
<span class="math inline">\(v_i\)</span> が <span
class="math inline">\(g_i(r_i)\)</span> を、 <span
class="math inline">\(g_i\)</span>
をほとんど知らなくても検証できるのです。</p>
<p>目指すところは、多項式 <span class="math inline">\(P(x)\)</span> を
<span class="math inline">\(a\)</span> で評価した結果が <span
class="math inline">\(b\)</span> 、つまり、 <span
class="math inline">\(P(a) = b\)</span> を <span
class="math inline">\(x\)</span>
が残る形で式変形して、二つの多項式が一致するかをランダムな点での評価（シュワルツ・ジッペルの補題）で確かめる方向です。</p>
<h3 id="多項式の割り算">多項式の割り算</h3>
<p>まずは、式変形した結果をお見せします。この式の意味は、「<span
class="math inline">\(P(x) - b = 0\)</span> という式は <span
class="math inline">\((x-a)\)</span> で割り切れ、その時の商は <span
class="math inline">\(Q(x)\)</span> である」となります。</p>
<p><span class="math display">\[
P(x) - b = Q(x)(x-a)
\]</span></p>
<p>この法則は、因数定理といいます。要は、「<span
class="math inline">\(f(a) = 0\)</span> ならば、 <span
class="math inline">\(f(x)\)</span> は <span
class="math inline">\((x-a)\)</span>
で必ず割り切れる」のです。この定理によって、<span
class="math inline">\(x\)</span> を残したまま <span
class="math inline">\(a,b\)</span>
を式の中に入れることができました。</p>
<p>では、実際に計算してみましょう。下の <span
class="math inline">\(f(x)\)</span> は <span
class="math inline">\(x\)</span> が <span
class="math inline">\(3\)</span> のときにゼロになるので、 <span
class="math inline">\((x-3)\)</span> で割り切れるはずです。</p>
<p><span class="math display">\[
f(x) = x^3 - 12x^2 + 47x - 60
\]</span></p>
<p><span class="math display">\[
\require{enclose}
\begin{align}
    x^2- 9x + 20 \phantom{{} + 0 + 00}\\
    x-3 \hspace{0.5em} \enclose{longdiv}{ \phantom{0} x^3 - 12x^2 + 47x
- 60 } \\
    {\underline{x^3 - 3x^2} \phantom{{} 0 + 47x - 60}} \\
  -9x^2   +   47x \phantom{{} + 00}\\
  \underline{-9x^2   +   27x} \phantom{{} + 00} \\
  20x   -   60 \\
    \underline{20x   -   60 } \\
    0
\end{align}
\]</span></p>
<p>左辺（ <span class="math inline">\(P(x) - b\)</span> ）と右辺（ <span
class="math inline">\(Q(x)(x-a)\)</span> ）を同じ <span
class="math inline">\(x\)</span> で評価した時に一致すれば、<span
class="math inline">\(P(a) = b\)</span>
であることも確かめられるのです。</p>
<div class="note">
<p>コラム: 因数定理</p>
<p><em>執筆中: 根と因数</em></p>
</div>
<h3 id="離散対数性">離散対数性</h3>
<p><span class="math inline">\(P(x)\)</span> と <span
class="math inline">\(Q(x)\)</span> をランダムな <span
class="math inline">\(s\)</span>
で評価した結果を証明者からもらうことで、検証者は <span
class="math inline">\(P_s - b = Q_s(s-a)\)</span>
を確かめるだけで良くなります。</p>
<p>しかし、ここで起きる問題は、証明者が事前に <span
class="math inline">\(s\)</span> を知っていれば、<span
class="math inline">\(a,b\)</span> に全く関係ない <span
class="math inline">\(P(x), Q(x)\)</span>
をいくらでも作れてしまうということです。またそもそも、 <span
class="math inline">\(P_s,Q_s\)</span>
を値として受け取ったところで、それが本当に <span
class="math inline">\(P(s), Q(s)\)</span>
を計算した結果なのかもよく分かりません。</p>
<p>さて、ここから一気に複雑になりますので、頑張ってついてきてください。</p>
<p>まずは、次のような性質を持つ <span
class="math inline">\(h(x)\)</span> を導入します。例えば、 <span
class="math inline">\(h\)</span> に <span
class="math inline">\(3+5\)</span> を入れた結果も <span
class="math inline">\(h(3)\)</span> と <span
class="math inline">\(h(5)\)</span>
を足した結果も同じという性質です。</p>
<p><span class="math display">\[
\begin{aligned}
h(a+b) &amp;= h(a) + h(b), \\
\\
h(ab) &amp;= a \cdot h(b), \\
\end{aligned}
\]</span></p>
<p>これを利用すると、先ほど例に出した <span
class="math inline">\(f(s)\)</span>
はこんな感じに変形することができるは分かるでしょうか。</p>
<p><span class="math display">\[
\begin{aligned}
h(f(s)) = 1 \cdot h(s^3) -12 \cdot h(s^2) + 47 \cdot h(s) -60 \cdot
h(s^0)
\end{aligned}
\]</span></p>
<p>ここで、<span class="math inline">\(h(x)\)</span>
に重要な性質を追加します。それは、<span
class="math inline">\(h(s)\)</span> の結果 <span
class="math inline">\(h_s\)</span> からは <span
class="math inline">\(h(x)\)</span> の入力となった <span
class="math inline">\(s\)</span>
は分からないという性質です。これはハッシュ関数にとても似ています。</p>
<p>よって、　<span class="math inline">\(h_{s^0},..,h_{s^3}\)</span>
を渡された証明者は <span class="math inline">\(h(f(s))\)</span> の結果
<span class="math inline">\(h_{f(s)}\)</span>
を計算することはできますが、<span class="math inline">\(f(s)\)</span> や
<span class="math inline">\(s\)</span>
が実際にどんな値かを知ることはできないのです。このような性質を離散対数性と言います。</p>
<h3 id="検証">検証</h3>
<p>検証者は、証明者に <span class="math inline">\(h(P(s))\)</span> と
<span class="math inline">\(h(Q(s))\)</span>
を計算してもらって、二つが正しいか確かめます。 <span
class="math inline">\(a,b\)</span> は証明者が主張した入力と結果で、<span
class="math inline">\(s\)</span> は検証者自身が知っています。</p>
<p><span class="math display">\[
h_{P(s)} - h_b = h_{Q(s)} (s - a)
\]</span></p>
<p>では、この式が成り立つか展開して確かめてみましょう。</p>
<p><span class="math display">\[
\begin{aligned}
h_{P(s)} - h_b &amp;= h_{Q(s)} (s - a) \\[0.8em]
h(P(s)) - h(b) &amp;= h(Q(s)) (s - a) \\[0.8em]
h(P(s) - b) &amp;= h(Q(s)(s - a)) \\[0.8em]
P(s) - b &amp;= Q(s)(s - a) \\
\end{aligned}
\]</span></p>
<p>もし証明者が <span class="math inline">\(P(a)\)</span> が <span
class="math inline">\(b&#39;\)</span>
と嘘をついた場合でも、因数定理によって <span
class="math inline">\(Q(x)\)</span>
を作ることがまずできませんし、次を満たすような偽の <span
class="math inline">\(h_{Q&#39;(s)}\)</span>
も作ることができません。なぜなら、<span class="math inline">\(s\)</span>
を知らないので、検証者が<span
class="math inline">\(h_{Q&#39;(s)}\)</span>
にどんな値を掛けるか分からず、どんな <span
class="math inline">\(Q&#39;\)</span>
を用意していいか分からないからです。</p>
<p><span class="math display">\[
h(Q&#39;(s)) \quad \stackrel{?}{=} \quad \frac{h_{P(s)} -
h_{b&#39;}}{(s-a)}
\]</span></p>
<p>このような性質を持つ <span class="math inline">\(h(x)\)</span>
をどう作るのかがまだ問題ですが、ランダム評価する <span
class="math inline">\(s\)</span>
と因数定理によって、検証者が大半の計算をせずに評価結果が正しいことを確かめられるようになりました。実際にはこの性質は楕円曲線上の演算によって得られますが、この章では深く触れません。</p>
<h3 id="コミットメント">コミットメント</h3>
<p><span class="math inline">\(P(a) = b\)</span>
を証明するには、証明者はこの <span
class="math inline">\(h_{P(a)}\)</span> と <span
class="math inline">\(h_Q(s)\)</span> を検証者に渡せばいいわけですが、
<span class="math inline">\(s, P(x)\)</span> は変わらないので <span
class="math inline">\(h_{P(a)}\)</span> を使い回すことができます。</p>
<p>この <span class="math inline">\(h_{P(a)}\)</span> を、<span
class="math inline">\(P(a)\)</span>
のコミットメントと呼びます。コミットメントは多項式ごとに用意する必要はありますが、同じ多項式の評価を証明する場合は、同じコミットメントを使用します。</p>
<h2 id="ランダムオラクル">ランダム・オラクル</h2>
<p>ここまでで、知られて良い乱数 <span class="math inline">\(r_i,
\beta_i\)</span> と、知られてはいけない乱数 <span
class="math inline">\(s\)</span> が登場しました。</p>
<p>乱数 <span class="math inline">\(s\)</span>
は最後まで秘匿するとして、<span class="math inline">\(r_i,
\beta_i\)</span>
にかんしては、証明者に作ってもらい検証者が正く生成されたかを確かめるという方法を取ります。これによって、証明者と検証者のやり取りが一回切りになります。一度セットアップした
<span class="math inline">\(h_{s^0},h_{s^1},..h_{s^i}\)</span>
はこの後もずっと使いまわせるので、あとは証明者が正しい手順で生成した
<span class="math inline">\(r_i\)</span> や <span
class="math inline">\(g_i\)</span>
などを一度に受け取り、検証するだけとなるのです。</p>
<p>ただし、乱数の生成のタイミングには注意が必要です。なぜなら、乱数を本来必要とする前に乱数が何であるかを知られてしまうと、任意の結果となる多項式をいくらでも作れてしまうからです。シュワルツ・ジッペルの補題は、多項式が乱数よりも前に存在することを前提としています。</p>
<p>では、どのように多項式よりも後に乱数を生成させるかというと、多項式のパラメーターやコミットメントをハッシュしたもの乱数としてしまう方法です。事前にハッシュがどのような値になるかを予測して多項式を決めることはできませんので、あとは、検証者が同じコミットメントなどをハッシュに入力して同じ乱数が生成されるかを確認すればいいだけです。</p>
<h3 id="ハッシュ関数-執筆中">ハッシュ関数 <em>執筆中</em></h3>
<h2 id="楕円曲線と有限体-執筆中">楕円曲線と有限体 <em>執筆中</em></h2>
<div class="note">
<p>コラム: 楕円軌道</p>
<p><em>執筆中: 惑星の軌道、ニュートンとケプラー</em></p>
</div>
<div class="note">
<p>コラム: 楕円曲線暗号</p>
<p><em>執筆中</em></p>
</div>
<h2 id="サムチェックプロトコル-執筆中">サムチェック・プロトコル
<em>執筆中</em></h2>
<h2 id="ここまでの見取り図-執筆中-1">ここまでの見取り図
<em>執筆中</em></h2>
<p><br></p>
<hr />
<h1 id="計算の畳み込み-執筆中">計算の畳み込み <em>執筆中</em></h1>
<h2 id="証明の再帰とは-執筆中">証明の再帰とは <em>執筆中</em></h2>
<h2 id="畳み込みとは-執筆中">畳み込みとは <em>執筆中</em></h2>
<h2 id="hypernova-執筆中">HyperNova <em>執筆中</em></h2>
<h3
id="多重線形多項式コミットメント-執筆中">多重線形多項式コミットメント
<em>執筆中</em></h3>
<h3 id="重のサムチェック-執筆中">2重のサムチェック <em>執筆中</em></h3>
<p><br></p>
<hr />
<h1 id="zkvm-執筆中">zkVM <em>執筆中</em></h1>
<h2 id="cpuの役割-執筆中">CPUの役割 <em>執筆中</em></h2>
<h2 id="命令の回路-執筆中">命令の回路　<em>執筆中</em></h2>
<h2
id="オフラインメモリチェック-執筆中">オフライン・メモリ・チェック　<em>執筆中</em></h2>
<h2 id="nebula-執筆中">Nebula <em>執筆中</em></h2>
<h2 id="スイッチボード-執筆中">スイッチ・ボード <em>執筆中</em></h2>
<h2 id="ビット演算-執筆中">ビット演算 <em>執筆中</em></h2>
<h2 id="浮動小数点数-執筆中">浮動小数点数 <em>執筆中</em></h2>
<h2 id="実行トレース-執筆中">実行トレース <em>執筆中</em></h2>
<h2 id="執筆中"><em>執筆中</em></h2>
<hr />
<ul>
<li>https://eprint.iacr.org/2025/385.pdf</li>
<li>https://eprint.iacr.org/2025/419.pdf</li>
<li>https://reilabs.notion.site/Spartan-on-WHIR-15bd2f80c8748076b9c3d427ad443864</li>
<li>https://eprint.iacr.org/2022/420.pdf</li>
</ul>
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="ClankPan" />
  <meta name="dcterms.date" content="2025-03-12" />
  <title>ゼロ知識証明を知りたい人のためのzkVM作成入門</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="./style.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">ゼロ知識証明を知りたい人のためのzkVM作成入門</h1>
<p class="author">ClankPan</p>
<p class="date">2025-03-12</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#はじめに" id="toc-はじめに">はじめに</a>
<ul>
<li><a href="#なぜzkvmなのか"
id="toc-なぜzkvmなのか">なぜzkVMなのか</a></li>
<li><a href="#zkvmのパラダイム"
id="toc-zkvmのパラダイム">zkVMのパラダイム</a></li>
<li><a href="#本書の想定する開発環境"
id="toc-本書の想定する開発環境">本書の想定する開発環境</a></li>
<li><a href="#著者について" id="toc-著者について">著者について</a></li>
</ul></li>
<li><a href="#ゼロ知識証明と計算圧縮"
id="toc-ゼロ知識証明と計算圧縮">ゼロ知識証明と計算圧縮</a>
<ul>
<li><a href="#解と検証の計算"
id="toc-解と検証の計算">解と検証の計算</a></li>
<li><a href="#シュワルツジッペルの補題"
id="toc-シュワルツジッペルの補題">シュワルツ・ジッペルの補題</a>
<ul>
<li><a href="#多項式とは" id="toc-多項式とは">多項式とは</a></li>
<li><a href="#多項式の一致" id="toc-多項式の一致">多項式の一致</a></li>
</ul></li>
<li><a href="#合計値での解の検証"
id="toc-合計値での解の検証">合計値での解の検証</a></li>
</ul></li>
<li><a href="#計算の変換" id="toc-計算の変換">計算の変換</a>
<ul>
<li><a href="#よく使われる計算の表現方法"
id="toc-よく使われる計算の表現方法">よく使われる計算の表現方法</a></li>
<li><a href="#行列式へ変換" id="toc-行列式へ変換">行列式へ変換</a>
<ul>
<li><a href="#行列とは" id="toc-行列とは">行列とは</a></li>
<li><a href="#行列で変数の切り替え"
id="toc-行列で変数の切り替え">行列で変数の切り替え</a></li>
</ul></li>
<li><a href="#多項式への変換" id="toc-多項式への変換">多項式への変換</a>
<ul>
<li><a href="#行列の要素を取り出す多項式を考える"
id="toc-行列の要素を取り出す多項式を考える">行列の要素を取り出す多項式を考える。</a></li>
<li><a href="#多項式を1つにまとめる"
id="toc-多項式を1つにまとめる">多項式を1つにまとめる。</a></li>
<li><a href="#打消して合計がゼロになる"
id="toc-打消して合計がゼロになる">打消して合計がゼロになる。</a></li>
<li><a href="#検証コストが減ってない"
id="toc-検証コストが減ってない">検証コストが減ってない。</a></li>
</ul></li>
</ul></li>
<li><a href="#サムチェックプロトコル"
id="toc-サムチェックプロトコル">サムチェック・プロトコル</a>
<ul>
<li><a href="#ランダムな値をどうするか"
id="toc-ランダムな値をどうするか">13.
ランダムな値をどうするか。</a></li>
<li><a href="#渡された多項式が期待しているものか"
id="toc-渡された多項式が期待しているものか">14.
渡された多項式が期待しているものか。</a></li>
</ul></li>
</ul>
</nav>
<p><br> <br></p>
<hr />
<h1 id="はじめに">はじめに</h1>
<p><em>このオンラインブックは執筆中です。完成版ではありません。<a
href="https://docs.google.com/forms/d/e/1FAIpQLSd5NN8awATTEVN4kI_itnnJRNdEEgkoEnRFLuUaoxmLBgJZZQ/viewform?usp=header">フィードバック</a>
はこちらから受け付けています。</em></p>
<p>本書では、アセンブリ言語にコンパイルされたプログラムの実行を証明する仮想マシン、つまりzkVMを作成を通して、ゼロ知識証明について学びます。実装にはパラダイムがありますが、その中でも比較的理解しやすいものを選びました。本書だけではzkVMの全てを知ることはできませんが、ここで得られた知識はゼロ知識証明の世界に飛び込む読者の足がかりになるはずです。一見、難しそうに見える数式やコードが出てきますが、全てステップ・バイ・ステップで説明してきますので、分からないと感じたらぜひ前の章に戻って見てください。</p>
<p>この本では、理論と実装のパートが分かれています。もし、理論の途中でわからなくなってしまったら、上からもう一度読み直して、理解できるところまで実装してみてください。手を動かしてみると、より理解が深まってその先へと進めると思います。また、この時代はChatGPTのようなLLMに質問することも理解の手助けになると思いますので、ぜひ活用してみてください。</p>
<p>この本の読者は数学やプログラムが得意である必要はなく、むしろパズルの解き方を時間をかけて理解できれば十分です。また、本書の理解には必要ないが重要な概念や補足、こぼれ話はコラムとしてまとめていきますので、身構えず気楽に読み進めてください。</p>
<h3 id="なぜzkvmなのか">なぜzkVMなのか</h3>
<p>ゼロ知識証明を知るのに、なぜzkVMを題材に選んだのでしょうか？これは、ここ最近のゼロ知識証明の研究の多くが、どうzkVMを作るかに向かっているからです。そもそもVMとはVirtual
Machineのことで、仮想機械、つまりプログラム上でCPUなどのハードウェアをシミュレートし、さらにその上でプログラムを動かすという階層高構造になる仕組みのことです。ゼロ知識証明では複雑な計算を証明したいわけですが、基本的には証明のプロトコルによって書き方が異なります。</p>
<p>計算そのものをどう分かりやすく表現するかが問題になりますが、これにはいくつか方法があります。一つは専用の言語を作ってその言語でプログラムを直接書くことです。しかし、プログラマは既存のプログラムを専用言語でいちいち書き直したくないですし、ツールによって言語を使い分けることも認知的なコストが高くなりがちです。</p>
<p>一般的なプログラミング言語を専用言語に変換する、といった方法もありますが、プログラミング言語もバージョンによって書き方が微妙に異なりますし、全てに対して専用のコンパイラを用意するのもコストに見合うかわかりません。</p>
<p>そこで、既存のどのプログラミング言語からもコンパイルできて、変更が滅多に行われない言語、つまりアセンブリ言語そのものを証明してしまおう、ということです。アセンブリ言語で書かれた計算を証明するには、CPUそのもの挙動をゼロ知識証明のフォーマットで一度だけ定義し、どんなプログラムに対しても同じゼロ知識証明の回路を使い回せばいいのです。すると、プログラマも普段の業務と同じように好きな言語でプログラムを書き、自然とその計算が証明されるわけです。</p>
<h3 id="zkvmのパラダイム">zkVMのパラダイム</h3>
<p>zkVMはあくまでも「やりたいこと」であって、実際にどのような実装かを指す言葉ではありません。実装にはいくつかのパラダイムがあります。一つはプログラムの実行を一つの大きな証明回路にして一度に証明しまう方式です。もう一つはプログラムの実行を小さなステップに分けて証明回路を繰り返し適用することで再帰的に証明する方式です。</p>
<p>前者をモノリシック（Monorithic）方式といい、後者をリカーシブ（Recursive）方式といいます。Monorithicで代表的なものはJolt/Lasso方式ですが、入門には難しすぎるので、比較的わかりやすいRecursiveのNova方式を本書では採用します。さらに、Novaの中でもわかりやすく今後の発展の基本となりそうなHyperNovaをベースに解説していきます。とくに、HyperNovaで使われる技術は、Joltでも使われるものが多く、学ぶメリットがあります。</p>
<div class="note">
<p>コラム: ゼロ知識証明の回路</p>
<p>ゼロ知識証明の中でもSNARKという分野では、計算をひとまとまりにした単位を回路と呼びます。面白いことにzkVMは、CPUを二進数のANDやORの論理回路から、有限体のADDやMULの証明回路で書き直していく作業になります。ある意味でzkVMは、論理演算を使わない別の世界のコンピューターをいえるかもしれません。</p>
</div>
<div class="note">
<p>コラム: Novaの一族</p>
<p>Novaは高速なRecursive方式として、2021年ごろに登場しました。その後も改良が登場しましたが、それらの名前はオリジナルのNova（新星爆発）にちなんで付けられていきました。</p>
<p>最初に登場したのがSuperNova（超新星爆発）です。その後すぐにHyperNova(極超新星爆発)が提案され、さらにその後すぐに二つを組み合わせたSuperHyperNovaなんていうのも提案されかけました。</p>
<p>爆発のインフレーションはすぐに終わりましたが、現在でも〇〇Novaという名称や、Nebula（星雲）や
ProtoStar（原始星）など宇宙にちなんだ名前が付けられています。</p>
<p>あなたのzkVMにも宇宙や星に関連する名前をつけてみるのも面白いかもしれません。</p>
</div>
<h3 id="本書の想定する開発環境">本書の想定する開発環境</h3>
<p><em>執筆中</em></p>
<h3 id="著者について">著者について</h3>
<p><em>執筆中</em></p>
<p><br></p>
<hr />
<h1 id="ゼロ知識証明と計算圧縮">ゼロ知識証明と計算圧縮</h1>
<p>ゼロ知識証明というのは、その名の通り、「自分が持っている情報を明かさず、持っていることだけを証明する」技術の総称です。自分が隠したい情報を秘匿することが主な内容ですが、最近は計算量を圧縮することができる特性が注目されています。</p>
<p>たとえば、ブロックチェーン上で何かを計算させると、その計算量に応じてとにかく支払うコストが莫大にかかります。そこで、少しでも計算量と通信を減らしたいという動機が生まれ、この技術に注目と投資が集まるようになりました。これが近年急速にゼロ知識証明の研究が進んでいる理由です。</p>
<div class="note">
<p>コラム: SNARK</p>
<p>情報を秘匿しなくてもいいから計算が正しいことを証明したい、という需要があります。これを他のゼロ知識証明と区別するため、SNARK（スナーク）と名付けられました。</p>
<p>サイズの証明が短く (succinct) 、やり取りが一度きり (non-interactive)
という意味です。さらに、ゼロ知識性がある場合はzkSNARKとZero
Knowledgeの頭文字であるzkを先頭につけます。</p>
</div>
<h2 id="解と検証の計算">解と検証の計算</h2>
<p>計算量を圧縮できるとはどういうことでしょうか。これは、問題を解く計算量と答えを検証する計算量が対応ではない、というありふれた問題として考えることができます。</p>
<p>たとえば、ソートを例に考えてみましょう。数字を順列に並び替える計算は、数列が順列であることを確かめるよりも多くの計算を必要とします。並び替え単純な方法は、最初の数字が右の数字よりも小さいかを比較して、大きければ入れ替える、という計算を全ての数字が満たすまで繰り返していきます。</p>
<p>一方で、数字が全て小さい順に並んでいるのを確かめるだけなら、左から順に数字を比較していくだけなので、数字の個数分の計算だけで済みます。つまり、100個の数字があるとすれば、ソートにはざっくり660回程度の計算が必要になりますが、確かめるには100回程度だけです。</p>
<p>このように、解く計算量よりも検証する計算の方が小さい、といった問題はありふれています。もし仮に、プログラムなどの計算をソートの解を求めることに置き換えることができるのなら、プログラムの計算が正しいかは、解が順列であるかを確かめるだけです。</p>
<p>ソートはあくまでも例えなので実際の証明には使いませんが、</p>
<ol type="1">
<li>計算をとある問題の解を求めることへ変換する、</li>
<li>その問題の解が正しいか検証してもらう、</li>
</ol>
<p>の二つに分けることができます。</p>
<h2 id="シュワルツジッペルの補題">シュワルツ・ジッペルの補題</h2>
<p>ソートの例の代わりに、シュワルツ・ジッペルの補題（Schwartz-Zippel
lemma）とSumcheck（合計チェック）いうものを使います。この二つによって、証明者が出した解を、検証者がより少ない計算で検証することができます。</p>
<p>ではいったい、どんな計算を減らすことができるのでしょうか？
それは、式の合計を求める計算です。</p>
<p>シュワルツ・ジッペルの補題とサムチェックを使うことで、証明者は式の合計がとある値になることを伝え、検証がそれが成り立つかを簡単に確かめることができるのです。</p>
<h3 id="多項式とは">多項式とは</h3>
<p>まずは、多項式が何かについておさらいしていきましょう。多項式とはその名の通り、項（係数
<span class="math inline">\(\times\)</span>
変数）が式中に1つ以上存在する式のことです。たとえば次のような式で、係数
<span class="math inline">\(a,b,c\)</span> と変数 <span
class="math inline">\(x,y,z\)</span>
からの項がいくつかあることがわかると思います。これらの式はこれ以上、項を減らすことはできません。</p>
<p><span class="math display">\[
\begin{aligned}
f(x) &amp;= ax^2 + bx + c \\
g(x,y,x) &amp;= ax + by + cz \\
\end{aligned}
\]</span></p>
<h3 id="多項式の一致">多項式の一致</h3>
<p>シュワルツ・ジッペルの補題は、「
<em>二つの多項式の変数をランダムな値で評価したときに同じ結果になれば、二つが同じ多項式であると見なせる</em>
」といった定理です。中学や高校の数学の授業で、「二つの式が交わる点を求めよ」という問題を解いたことはないでしょうか？
2つのグラフは、ほとんどの場所で重ならず、一点か二点だけでしか交わりません。</p>
<p>2つの多項式をグラフにプロットしたときに、交わる点は全体の中では驚くほど少ないということです。なので、全く異なる多項式が、完全にランダムな点で交わる確率は極僅かになります。この確率は適切に設定すれば実用上無視できる確率になります。どれくらいかというと、地球上のすべての砂粒の中から、私がまいた砂の1粒を1回で選び出す確率よりも低くなります。</p>
<p><em>執筆中: 2つの式をプロットしたグラフを用意する。</em></p>
<h2 id="合計値での解の検証">合計値での解の検証</h2>
<p>特定の範囲では常に0になる多項式を見つけることができれば、検証者はその範囲の全ての値の合計も0であることを確かめれば良いのです。これにはサムチェックを使います。では、シュワルツ・ジッペルの補題はどこで出てくるかとういうと、サムチェックの中に出てきます。この辺りは後ほど解説しますので、身構えず読み進めてみてください。</p>
<div class="note">
<p>コラム: 計算量を表すオーダー</p>
<p>これを、オーダー（ <span class="math inline">\(O\)</span>
）という計算量を示す概念を導入して考えてみましょう。計算量は計算によって変化する個数
<span class="math inline">\(N\)</span>
が計算の中でどれだけ影響するかで表します。もし、<span
class="math inline">\(N\)</span>
の数字があって全ての数字を一度だけ見る計算なら、<span
class="math inline">\(O(N)\)</span>
となります。全ての数字に対して、全ての数字を掛け合わせる計算だとすれば、1つに対して
<span class="math inline">\(N\)</span> 回の計算が行われ、それが <span
class="math inline">\(N\)</span> 回繰り返されるので、<span
class="math inline">\(O(N \times N)\)</span> 、つまり、<span
class="math inline">\(O(N^2)\)</span> になります。</p>
<p>ソートには最速でも <span class="math inline">\(O(n\log{n})\)</span>
を必要とします。しかし、順列であることを確かめるだけだと、単純に考えても
<span class="math inline">\(O(n)\)</span> だけです。</p>
<p><span class="math inline">\(N\)</span>
が小さい時にはそれほど違いを感じませんが、 <span
class="math inline">\(N\)</span> が1,000や10,000
などになってくると計算回数にかなりの差が出てきます。</p>
<p>このように、大きな <span class="math inline">\(N\)</span>
に対してどれだけ違うか、をみる指標なので、 <span class="math inline">\(3
\times N\)</span> などの定数は無視して表記します。実際、大きな <span
class="math inline">\(N\)</span>
に対しては定数がかかっていてもそれほどの差は出ません。</p>
</div>
<div class="note">
<p>コラム: 式を評価？</p>
<p>多項式に限らず、式の変数に値で代入して結果を求めることを「評価」するといいます。この単語は英語由来のevaluationを直訳したものなので、日本語にすると少し不思議な感じがします。evaluationには値付けという意味があるので、式の値を求める述語としては少し納得できます。</p>
<p>どちらにしろ、数学の世界では評価という単語が使われていますので、計算する、くらいの意味として覚えておいてください。</p>
</div>
<p><br></p>
<hr />
<h1 id="計算の変換">計算の変換</h1>
<p>証明したい計算、つまりプログラム、を多項式の形で表現できれば、どうやら証明できそうなことが分かってきました。ここからは、計算をどう多項式に変換していくかについて考えていきます。プログラムを含めた色々な種類の計算のフォーマットの全てから直接多項式に変換する方法を考えるのは、非常にコストが高い作業になります。そこで、このような問題を解決するのによく用いられる手法が中間表現です。多様なフォーマットから変換しやすく、目的にフォーマットにも変換しやすい表現を中間に挟むことで、開発のコストを下げるという考え方です。</p>
<h2 id="よく使われる計算の表現方法">よく使われる計算の表現方法</h2>
<p>プログラムを多項式に変換していく前ステップとして、まずは計算を <span
class="math inline">\(a \times b = c\)</span>
の連なりで表現していきます。ルールは、a,b,cの項の中にはいくら足し算を入れもていいですが、掛け算は1行につき
<span class="math inline">\(a \times b\)</span>
の一回だけですので、もう一度掛け算が必要な場合は次の行で行います。</p>
<p>たとえば、フィボナッチ数列なら次のようになります。aとbを足した結果がcとなり、次の行ではbとcが足されdとなっています。変数が同じなら、
<span class="math inline">\(1\times c = (a + b)\)</span>
でも構いません。</p>
<p><span class="math display">\[
\begin{aligned}
(a + b) \times 1 &amp;= c \\
(b + c) \times 1 &amp;= d \\
(c + d) \times 1 &amp;= e \\
(d + e) \times 1 &amp;= f \\
\end{aligned}
\]</span></p>
<p>変数に値を入れてみると、次のようになるはずです。簡単ですので、合っているか手で計算してみてください。この
<span class="math inline">\(a\)</span> から <span
class="math inline">\(f\)</span> の値が計算の解となるわけです。</p>
<p><span class="math display">\[
a = 1, b = 2, c = 3,d = 5,e = 8,f = 13
\]</span></p>
<p><span class="math inline">\(ax^3 + b x^2 + cx + d = e\)</span>
なら次のようになります。 <span class="math inline">\(x^2\)</span> と
<span class="math inline">\(x^3\)</span> はそれ自体が <span
class="math inline">\(x\)</span> の掛け算なので、<span
class="math inline">\(v,w\)</span> に割り当ててあげて、<span
class="math inline">\(ax^3\)</span> などは中間結果として <span
class="math inline">\(\alpha\)</span> と置いてあげます。</p>
<p><span class="math display">\[
\begin{aligned}
x \times x &amp;= v \\
x \times v &amp;= w \\
a \times w &amp;= \alpha \\
b \times v &amp;= \beta \\
c \times x &amp;= \gamma \\
(\alpha + \beta + \gamma + d) \times 1 &amp;= e
\end{aligned}
\]</span></p>
<p>この表現方法でプログラムのすべてを書き出すのは少々骨が折れる作業ですが、全くできないという程でもありません。また、変換するツールなどもあるので、それらを使えば好きなプログラムをこの形式に直すこともできます。先ほど説明した専用言語やコンパイラのことです。</p>
<p>全てのプログラムをこの形式に変換できるわけではありませんが、表現が難しいものは別の技術を使ってカバーします。</p>
<div class="note">
<p>コラム: ルックアップ</p>
<p><em>執筆中, ビット演算、浮動小数点数, 行列の掛け算</em></p>
</div>
<h2 id="行列式へ変換">行列式へ変換</h2>
<p>さて、プログラムを単純な形で表現することができましたが、これだけでは不十分です。なぜなら、<span
class="math inline">\(a,b,c,d,v,w,x,..\)</span>
などの変数は、文字的に同じ変数と見なしているだけで、それらが同じであるかを制約するものは何もないからです。</p>
<p>このような変数の使い回しを式で表現するには、行列の掛け算を使います。まずは、行列について少し触れます。</p>
<h3 id="行列とは">行列とは</h3>
<p><em>執筆中</em></p>
<h3 id="行列で変数の切り替え">行列で変数の切り替え</h3>
<p>用意するのは、要素が <span class="math inline">\(0,1\)</span>
で構成された <span class="math inline">\(m \times n\)</span> 行列 <span
class="math inline">\(A\)</span> と、すべての変数が列挙された <span
class="math inline">\(n \times 1\)</span> 行列 <span
class="math inline">\(Z\)</span> です。すると、次のように、<span
class="math inline">\(Z\)</span>
から選ばれた変数の合計が結果となります。</p>
<p><span class="math display">\[
\begin{aligned}
A \cdot Z &amp;=
\begin{bmatrix}
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix} \\
\end{aligned}
\]</span></p>
<p>左の行列の中で、1になっている列番目が、対応する <span
class="math inline">\(Z\)</span>
の行番目になっていることがわかります。1行目では [1 1 0 0 …]
となっているので、 <span class="math inline">\(Z\)</span>
の1行目と2行目の <span class="math inline">\(a,b\)</span>
が選択され、行列の掛け算の規則により、それらが足された値が結果の行列の1行目の要素となっています。</p>
<p><span class="math display">\[
(1 \cdot a) + (1 \cdot b) + (0 \cdot c) + (0 \cdot d) + (0 \cdot e) + (0
\cdot f) + (0 \cdot 0) + (0 \cdot 1)
\]</span></p>
<p>これは、先ほどのフィボナッチ数列の <span class="math inline">\(a
\times b = c\)</span> のうち、<span class="math inline">\(a\)</span>
のすべての項の集合になっていることがわかります。 <span
class="math inline">\(b,c\)</span>
についても、次のように変数を選び、その和をとります。ただし、フィボナッチ数列では
<span class="math inline">\(a\)</span>
以外では和を取らないので、ただ変数を選択しただけになっています。</p>
<p><span class="math display">\[
\begin{aligned}
B \cdot Z &amp;=
\begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}\\
\\
C \cdot Z &amp;=
\begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\
\end{aligned} \\
\]</span></p>
<p>最終的に、これを行列の式で表すと、次のようになります。 <span
class="math inline">\(\circ\)</span> 記号は アダマール積（Hadamard
Product）といって、重なり合う要素の掛け算だけをする演算記号です。普通の行列の掛け算は
<span class="math inline">\(\cdot\)</span> 記号で表されます。</p>
<p><span class="math display">\[
\begin{aligned}
A \cdot Z \quad \circ \quad B \cdot Z  \quad &amp;= \quad C \cdot Z  \\
\\
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix}
\quad
\circ
\quad
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}
\quad
&amp;=
\quad
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\
\end{aligned}
\]</span></p>
<p>行列を使うことで、どの変数をどう使うかを表現することができました。この表現方法はR1CS（Rank-1
Constrain System）と呼ばれます。</p>
<h2 id="多項式への変換">多項式への変換</h2>
<p>行列式のままでは、掛け算などの手順が複雑なので、これを一旦次のような式に変形します。
<span class="math inline">\(\sum\)</span> は <span
class="math inline">\(i\)</span>
を0からN-1まで順番にあげていき、その和を取る演算記号です。上の行列式の
<span class="math inline">\(0\)</span>
行目の計算と一致していることがわかると思います。</p>
<p><span class="math display">\[
\sum_{i=0}^{N-1}{A[0,i] \cdot Z[i]} \quad \cdot \quad
\sum_{i=0}^{N-1}{B[0,i] \cdot Z[i]} \quad = \quad
\sum_{i=0}^{N-1}{C[0,i] \cdot Z[i]}
\]</span></p>
<p>上の式では、<span class="math inline">\(A[X,Y]\)</span>
でX行Y列の要素を取り出していますが、これは多項式の一部ではありません。なので、変数
<span class="math inline">\(x\)</span>
によって同じように取り出せなくてはなりません。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f(x) = \sum_{i=0}^{N-1}{A(x,i) \cdot Z(i)} \quad \cdot \quad
\sum_{i=0}^{N-1}{B(x,i) \cdot Z(i)} \quad - \quad
\sum_{i=0}^{N-1}{C(x,i) \cdot Z(i)} = 0, \\
&amp;\{x | 0 \le x \lt M \}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(A(x,y)\)</span>
などをどう作るかは置いておいて、<span
class="math inline">\(f(x)=0\)</span> の形に近くなってきました。どんな
<span class="math inline">\(x\)</span>
とはいかずとも、0からM-1の区間なら0になります。</p>
<h3
id="行列の要素を取り出す多項式を考える">行列の要素を取り出す多項式を考える。</h3>
<p><span class="math inline">\(A(x,y)\)</span>
を作るにはどうしたらいいでしょうか？　まずは変数が1つの<span
class="math inline">\(Z(x)\)</span> から考えてみることにします。</p>
<p><span class="math inline">\([a,b,c,d,e,f,0,1]\)</span>
からn番目の要素を取り出すのは、先ほどの <span
class="math inline">\(\{0,1\}\)</span>
の行列で使ったテクニックを使います。つまり、取り出したい要素だけ1にして、それ以外は0にするという方法です。</p>
<p><span class="math display">\[
\begin{aligned}
Z(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8) &amp;= (x_1 \cdot a) + (x_2
\cdot b) \\
&amp;+ (x_3 \cdot c) + (x_4 \cdot d) \\
&amp;+ (x_5 \cdot e) + (x_6 \cdot f) \\
&amp;+ (x_7 \cdot 0) + (x_8 \cdot 1)
\end{aligned}
\]</span></p>
<p>しかし、これでは変数の数が多い上に、2つ以上を選択してその合計値を取ってくることが出来てしまします。そこで、<span
class="math inline">\(Z\)</span> への入力は <span
class="math inline">\(n\)</span>
を二進数で渡せるようにします。これだと、要素が8個ならば3つの変数だけでよく、さらに同時に1つの要素しか選択できません。</p>
<p>用意するのは、2つの二進数が一致すれば <span
class="math inline">\(1\)</span> , 異なれば <span
class="math inline">\(0\)</span>
になる多項式です。これは次のように作ることができます。 <span
class="math inline">\(\prod\)</span> は <span
class="math inline">\(i\)</span>
を増やしていって、その積をとる演算記号です。 <span
class="math inline">\(\sum\)</span>
の掛け算バージョンだと思ってください。</p>
<p><span class="math display">\[
eq((x_1, x_2, x_3), (y_1, y_2, y_3)) = \prod_{i=1}^3{(1-x_i)(1-y_i) +
x_i y_i}
\]</span></p>
<p>3bitはここに書くのは長いので2bitにしますが、展開するとこのようになります。ビットが違う項はゼロになるので、一つでもゼロになれば掛け算によって結果もゼロになります。</p>
<p><span class="math display">\[
\begin{aligned}
eq((1,0), (1,0)) = \{(1-1)(1-1) + 1 \cdot 1 \} \cdot   \{(1-0)(1-0) + 0
\cdot 0 \} &amp;= 1, \\
eq((0,1), (1,1)) = \{(1-0)(1-1) + 0 \cdot 1 \} \cdot   \{(1-1)(1-1) + 1
\cdot 1 \} &amp;= 0, \\
\end{aligned}
\]</span></p>
<p>ということで、<span class="math inline">\(eq\)</span> を使うと <span
class="math inline">\(Z\)</span> は次のように書くことができます。 <span
class="math inline">\(X\)</span> は <span class="math inline">\((x_1,
x_2, x_3)\)</span> のことです。</p>
<p><span class="math display">\[
\begin{aligned}
Z(X) &amp;= a \cdot eq(X, (0,0,0)) + b \cdot eq(X, (0,0,1)) \\
&amp;+ c \cdot eq(X, (0,1,0)) + d \cdot eq(X, (0,1,1)) \\
&amp;+ e \cdot eq(X, (1,0,0)) + f \cdot eq(X, (1,0,1)) \\
&amp;+ 0 \cdot eq(X, (1,1,0)) + 1 \cdot eq(X, (1,1,1))
\end{aligned}
\]</span></p>
<p>これを定義にしてみましょう。
少し複雑なので順を追って説明していきます。 <span
class="math inline">\(y\in \{0,1\}^{\log N}\)</span>
は言葉にするなら、「Nをビットで表したときのすべてのパターン」です。<span
class="math inline">\(Z[X]\)</span>
は定数なので式を展開したときには実際の値が入ります。つまりこの式は、
<span class="math inline">\(X\)</span> と <span
class="math inline">\(y\)</span> のビットが一致するとき、それに対応する
<span class="math inline">\(Z\)</span>
の要素を取り出す、ということになります。</p>
<p><span class="math display">\[
Z(X) = \sum_{y\in \{0,1\}^{\log N}}{Z[X] \cdot eq(X, y)}
\]</span></p>
<p>例えば、このようになります。</p>
<p><span class="math display">\[
\begin{aligned}
Z((0,0,0)) &amp;= a, \\
Z((0,0,1)) &amp;= b, \\
Z((0,1,0)) &amp;= c, \\
\end{aligned}
\]</span></p>
<p><span class="math inline">\(A,B,C\)</span>
も同じように定義することができます。ただし、行と列の二つを指定する必要があるので、それぞれの要素に対して
<span class="math inline">\(eq\)</span> を二つかけてあげます。</p>
<p><span class="math display">\[
A(X_1, X_2) = \sum_{y_1\in \{0,1\}^{\log M}} \sum_{y_2\in \{0,1\}^{\log
N}}{A[X_1, X_2] \cdot eq(X_1, y_1) \cdot eq(X_2, y_2)}
\]</span></p>
<p><span class="math inline">\(eq\)</span>
をベースに作った多項式は嬉しい性質があるので、他と区別できるようこれ以降は
<span
class="math inline">\(\tilde{Z}(\cdot),\tilde{A}(\cdot),\tilde{B}(\cdot),\tilde{C}(\cdot)\)</span>
と表記しておきます。</p>
<h3 id="多項式を1つにまとめる">多項式を1つにまとめる。</h3>
<p>定義した多項式を一つにまとめます。</p>
<p><span class="math display">\[
\begin{aligned}
G(X) &amp;= \sum_{y\in \{0,1\}^{\log N}} \tilde{A}(X, y) \cdot
\tilde{Z}(y)
\cdot \sum_{y\in \{0,1\}^{\log N}} \tilde{B}(X, y) \cdot \tilde{Z}(y)
- \sum_{y\in \{0,1\}^{\log N}} \tilde{C}(X, y) \cdot \tilde{Z}(y) \\
\\
&amp;X \in \{0,1\}^{\log M}
\end{aligned}
\]</span></p>
<p>この <span class="math inline">\(G\)</span> は <span
class="math inline">\(X\)</span> の全てのパターンで <span
class="math inline">\(G(X) = 0\)</span>
が成り立つはずです。もしどれか一つでも <span
class="math inline">\(0\)</span> でなければ、それは不正な操作が行われ、
<span class="math inline">\(a \times b = c\)</span>
のどこかが間違っているということになります。例えば、 <span
class="math inline">\(3 \times 2 = 5\)</span>
のような式が含まれているということです。</p>
<p>行列の行数 <span class="math inline">\(M = 4\)</span>
なら変数は2つで、次のようになります。</p>
<p><span class="math display">\[
G((0,0)) = G((0,1)) = G((1,0)) = G((1,1)) = 0
\]</span></p>
<h3 id="打消して合計がゼロになる">打消して合計がゼロになる。</h3>
<p>全て <span class="math inline">\(0\)</span> になるのなら、合計も
<span class="math inline">\(0\)</span>
であるはずなので、一つの式にまとめることができます。 <span
class="math display">\[
\sum_{y\in \{0,1\}^{\log M}} G(y) = 0
\]</span></p>
<p>しかし、例えば、<span class="math inline">\(G((0,0)) = 1, G((0,1)) =
-1\)</span> だとすると、お互いを打ち消してしまい、合計として <span
class="math inline">\(0\)</span> になることを防げません。</p>
<p>そこで、<span class="math inline">\(G\)</span>
にランダムな係数をかけて、打消し合う可能性を小さくするという発想が考えられます。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{y\in \{0,1\}^{\log M}} r_i \cdot G(y) \\
\\
&amp;= r_1 \cdot G((0,0)) + r_2 \cdot G((0,1)) + r_3 \cdot G((1,0)) +
r_4 \cdot G((1,1)) \\
&amp;= 1 \cdot r_1 + (-1) \cdot r_2 + 0 \cdot r_3 + 0 \cdot r_4\\
&amp;\ne 0
\end{aligned}
\]</span></p>
<p>だだし、これでは変数がなく、多項式ではなくなってしまうので、次のようにしてあげることで、多項式のままにすることができます。</p>
<p><span class="math display">\[
\tilde{Q}(\beta) = \sum_{y\in \{0,1\}^{\log M}} G(y) \cdot eq(y, \beta)
= 0
\]</span> 式を見ると、<span class="math inline">\(G\)</span>
にかかるランダムな係数が、<span class="math inline">\(eq(y,
\beta)\)</span>
によって変化していくことがわかります。さらに、　ランダムな値 <span
class="math inline">\(\beta\)</span> が <span
class="math inline">\(\{0,1\}^s\)</span> でない限りは、 <span
class="math inline">\(eq\)</span> がゼロになることはありません。なので、
<span class="math inline">\(eq\)</span>
はランダムな変数によって係数が変わり、さらにそれ自体が0にならない、という嬉しい性質があるのです。</p>
<p>例えば、<span class="math inline">\(\beta = (11, 22)\)</span>
ならば、次のように展開できます。</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{Q}((11, 22)) &amp;= G((0,0)) \cdot (1-11) \cdot (1-22) \\
&amp;+ G((0,1)) \cdot  (1-11) \cdot 22 \\
&amp;+ G((1,0)) \cdot  11 \cdot (1-22) \\
&amp;+ G((1,1)) \cdot  11\cdot 22 \\
\end{aligned}
\]</span></p>
<h3 id="検証コストが減ってない">検証コストが減ってない。</h3>
<p><span class="math inline">\(\tilde{Q}\)</span>
を展開してみるとわかるのですが、<span class="math inline">\(G\)</span>
がゼロになるので、<span class="math inline">\(f(x) = 0 \cdot x_1 + 0
\cdot x_2\)</span> のような、全ての項の係数が <span
class="math inline">\(0\)</span>
となるゼロ多項式となってしまいます。これでは、この多項式を検証者が渡されても何を検証していいか分からず、式の正当性を確かめられません。
<span class="math inline">\(G\)</span> が 本当に <span
class="math inline">\(0\)</span> であるかを確かめてもうらうには、<span
class="math inline">\(G\)</span>
の変数を残さなくてはいけないのです。</p>
<p>そこで、<span class="math inline">\(Q(\beta)\)</span>
から合計する前の項を取り出し、 <span class="math inline">\(g(X)\)</span>
とします。検証者には、この <span class="math inline">\(g\)</span> が
<span class="math inline">\(\{0,1\}^s\)</span> の全てで <span
class="math inline">\(0\)</span>
になることを確かめてもらうことで、計算が正しかったと検証してもらいます。</p>
<p><span class="math display">\[
g(X) =  G(X) \cdot eq(X, \beta)
\]</span></p>
<p>検証者に直接 <span class="math inline">\(g(X)\)</span>
を渡して、全パターンを試してもらうこともできますが、それでは計算が減るどころか少し増えてしまいます。</p>
<p>ここで使えるのが、sumcheck protocol
です。検証者が全パターンを試すよりも少ないコストで、全てのパターンが
<span class="math inline">\(0\)</span>
であることを証明することができす。</p>
<p><br></p>
<hr />
<h1 id="サムチェックプロトコル">サムチェック・プロトコル</h1>
<p>いよいよ登場しました、Sumcheck Protocol です。
仕組みを言葉で表現するならば、「変数が1つの多項式に分解し、それぞれが同じ多変数多項式がベースであることをランダムな点で検証してもらう。」です。</p>
<p>多変数多項式とは、 <span class="math inline">\(f(x,y,z) = ax + by +
cz\)</span> のような変数が複数ある式で、単変数多項式とは <span
class="math inline">\(h(x) = ax + b\)</span>
のような変数が一つだけの式の事です。では、なぜ変数ごとに式を分けると計算量が減るかを考えてみましょう。</p>
<p>単純に考えると、3変数多項式なら、<span
class="math inline">\(f\)</span>
の中の3つの変数の評価を8パターンで試すので、<span
class="math inline">\(3 \times 2^3 = 24\)</span>
の計算が必要になります。
一方で、3変数多項式を3つの単変数多項式に分解すると、変数を評価は同じく8パターンですが、式中の変数は1つだけなので、
<span class="math inline">\(1 \times 2^3 = 8\)</span> となります。</p>
<p>Sumcheck Protocol では1つの式ごとに3回の評価が必要なだけなので、
<span class="math inline">\(O(N)\)</span>
ですが、全パターンを評価するのは <span class="math inline">\(O(N \cdot
2^N)\)</span> となります。</p>
<p>このように、検証者の評価の回数を減らしつつ、適切に元の多変数多項式が分けられているのかを証明するのがこの
Sumcheck Protocolの肝なのです。</p>
<p>ではまず、単変数への変換方法を考えます。ここでは <span
class="math inline">\(g(X)\)</span> を取り扱いたいので、ひとまず、 <span
class="math inline">\(X = (x_1, x_2)\)</span> としておきます。
検証者には次の3つの多項式と使用したランダムな3つの値 <span
class="math inline">\(r1, \beta_1, \beta_2\)</span> を渡します。この
<span class="math inline">\(r1\)</span>
は検証者から最初にもらったり、改竄できない形で証明者が生成したりします。</p>
<p><span class="math display">\[
\begin{aligned}
g(X) &amp;=  G(X) \cdot eq(X, (\beta_1, \beta_2)), \\
g_1(x_1) &amp;= \sum_{y \in \{0,1\}}{g((x_1, y))}, \\
g_2(x_2) &amp;= g((r_1, x_2)), \\
\end{aligned}
\]</span></p>
<p>検証者は、<span class="math inline">\(g(X)\)</span>
が全てのパターンで <span class="math inline">\(0\)</span> になることを
<span class="math inline">\(g_1, g_2\)</span>
を使って確かめていきます。まず、<span
class="math inline">\(g_1(x)\)</span> を使って、<span
class="math inline">\(G(X)\)</span> がどのパターンでも <span
class="math inline">\(0\)</span>
であるという主張を確かめます。この時点では <span
class="math inline">\(g_1(x)\)</span> が　<span
class="math inline">\(G(X)\)</span>
を元に作られているかはまだ検証できていませんが、ひとまず <span
class="math inline">\(G(X)\)</span>
がゼロになりそうなことは分かりました。</p>
<p><span class="math display">\[
g_1(0) = g_1(1) = 0
\]</span></p>
<p>なので検証者は、本当に <span class="math inline">\(g_1(x)\)</span> が
<span class="math inline">\(G(X)\)</span> の <span
class="math inline">\(x_2\)</span> を <span
class="math inline">\(0\)</span> と <span
class="math inline">\(1\)</span>
で評価した多項式であるかを確かめなければなりません。方針は、シュワルツ・ジッペルの補題
を使って、ランダムな点で評価して同じ多項式は同じと見なせる、という性質を使います。つまり、<span
class="math inline">\(g_1(x)\)</span> と <span
class="math inline">\(G(X)\)</span> を <span
class="math inline">\(x_1,x_2\)</span> を <span
class="math inline">\(r_1,r_2\)</span>
で評価してその結果を比べるということです。</p>
<p>しかし、<span class="math inline">\(g_1(x)\)</span> の内部の <span
class="math inline">\(x_2\)</span> はすでに <span
class="math inline">\(0,1\)</span> で評価されてしまっているので、<span
class="math inline">\(g_2(x)\)</span> を代わりに使います。まずは、<span
class="math inline">\(g_1(x)\)</span> と <span
class="math inline">\(g_2(x)\)</span>
が同じ多項式であるかを確かめましょう。ちなみに、この時点で <span
class="math inline">\(g_1, g_2\)</span> の内部で本当に <span
class="math inline">\(g\)</span> が使われているか分からないので、<span
class="math inline">\(g\)</span> の代わりに <span
class="math inline">\(s, s&#39;\)</span> をおいておきます。</p>
<p><span class="math display">\[
\begin{aligned}
g_1(r_1) &amp;= g_2(0) + g_2(1) \\
\\
\sum_{y \in \{0,1\}}{s((r_1, y))} &amp;= s&#39;((r_1, 0)) + s&#39;((r_1,
1))
\end{aligned}
\]</span></p>
<p><span class="math inline">\(g_1, g_2\)</span> がどうやら同じ多項式
<span class="math inline">\(s\)</span>
を元に作られたということは確かめられました。そして、<span
class="math inline">\(g_2\)</span> を使うことで、<span
class="math inline">\(G(X)\)</span>
と同じ多項式であるかも確かめることができます。これには、 <span
class="math inline">\(G\)</span> を <span class="math inline">\(r_1,
r_2\)</span> で評価し、その結果を <span
class="math inline">\(g_2\)</span> を <span
class="math inline">\(r_2\)</span>
で評価した結果と比べます。すると、<span
class="math inline">\(g_2\)</span> の内部にある <span
class="math inline">\(x_1\)</span> は既に <span
class="math inline">\(r_1\)</span>
で評価されているので、同じランダムな点で二つの多項式を評価し比較することができるのです。</p>
<p><span class="math display">\[
\begin{aligned}
G((r_1, r_2))  &amp;= g_2(r_2) \\
\\
&amp;= s((r_1, r_2)) \\
\end{aligned}
\]</span></p>
<p>二つが同じ値になるなら、<span class="math inline">\(g_1\)</span>
の内部で使われている多項式 <span class="math inline">\(s\)</span> は
<span class="math inline">\(G\)</span> と同じなので、<span
class="math inline">\(g_1(0) = g_1(1) = 0\)</span>
によって、全てのパターンで <span class="math inline">\(G\)</span>
がゼロであることも検証できました。</p>
<p>ここまでは <span class="math inline">\(X\)</span>
の変数が2つでしたが、3つ以上の場合には</p>
<p><span class="math display">\[
\begin{aligned}
g_2(r2) &amp;= g_3(0) + g_3(1), \\
g_3(r3) &amp;=  g_4(0) + g_4(1), \\
...
\end{aligned}
\]</span></p>
<p>と検証しいき、<span class="math inline">\(G((r_1, r_2,.., r_n)) =
g_n(r_n)\)</span> となることを確かめます。</p>
<h2 id="ランダムな値をどうするか">13. ランダムな値をどうするか。</h2>
<h2 id="渡された多項式が期待しているものか">14.
渡された多項式が期待しているものか。</h2>
<hr />
<p>(*)
重要な定理を導入すると、「非零多項式には根（ゼロ点）が多くない」を利用することができる。</p>
</body>
</html>

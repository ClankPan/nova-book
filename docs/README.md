---
title: ゼロ知識証明を知りたい人のためのzkVM作成入門

author: ClankPan
date: 2025-03-12

css:
- ./style.css
---

<br>
<br>

---

# はじめに

*このオンラインブックは執筆中です。完成版ではありません。[フィードバック](https://docs.google.com/forms/d/e/1FAIpQLSd5NN8awATTEVN4kI_itnnJRNdEEgkoEnRFLuUaoxmLBgJZZQ/viewform?usp=header) はこちらから受け付けています。*

本書では、アセンブリ言語にコンパイルされたプログラムの実行を証明する仮想マシン、つまりzkVMを作成を通して、ゼロ知識証明について学びます。実装にはパラダイムがありますが、その中でも比較的理解しやすいものを選びました。本書だけではzkVMの全てを知ることはできませんが、ここで得られた知識はゼロ知識証明の世界に飛び込む読者の足がかりになるはずです。一見、難しそうに見える数式やコードが出てきますが、全てステップ・バイ・ステップで説明してきますので、分からないと感じたらぜひ前の章に戻って見てください。

この本では、理論と実装のパートが分かれています。もし、理論の途中でわからなくなってしまったら、上からもう一度読み直して、理解できるところまで実装してみてください。手を動かしてみると、より理解が深まってその先へと進めると思います。また、この時代はChatGPTのようなLLMに質問することも理解の手助けになると思いますので、ぜひ活用してみてください。

この本の読者は数学やプログラムが得意である必要はなく、むしろパズルの解き方を時間をかけて理解できれば十分です。また、本書の理解には必要ないが重要な概念や補足、こぼれ話はコラムとしてまとめていきますので、身構えず気楽に読み進めてください。

###  なぜzkVMなのか

ゼロ知識証明を知るのに、なぜzkVMを題材に選んだのでしょうか？これは、ここ最近のゼロ知識証明の研究の多くが、どうzkVMを作るかに向かっているからです。そもそもVMとはVirtual Machineのことで、仮想機械、つまりプログラム上でCPUなどのハードウェアをシミュレートし、さらにその上でプログラムを動かすという階層高構造になる仕組みのことです。ゼロ知識証明では複雑な計算を証明したいわけですが、基本的には証明のプロトコルによって書き方が異なります。

計算そのものをどう分かりやすく表現するかが問題になりますが、これにはいくつか方法があります。一つは専用の言語を作ってその言語でプログラムを直接書くことです。しかし、プログラマは既存のプログラムを専用言語でいちいち書き直したくないですし、ツールによって言語を使い分けることも認知的なコストが高くなりがちです。

一般的なプログラミング言語を専用言語に変換する、といった方法もありますが、プログラミング言語もバージョンによって書き方が微妙に異なりますし、全てに対して専用のコンパイラを用意するのもコストに見合うかわかりません。

そこで、既存のどのプログラミング言語からもコンパイルできて、変更が滅多に行われない言語、つまりアセンブリ言語そのものを証明してしまおう、ということです。アセンブリ言語で書かれた計算を証明するには、CPUそのもの挙動をゼロ知識証明のフォーマットで一度だけ定義し、どんなプログラムに対しても同じゼロ知識証明の回路を使い回せばいいのです。すると、プログラマも普段の業務と同じように好きな言語でプログラムを書き、自然とその計算が証明されるわけです。

###  zkVMのパラダイム

zkVMはあくまでも「やりたいこと」であって、実際にどのような実装かを指す言葉ではありません。実装にはいくつかのパラダイムがあります。一つはプログラムの実行を一つの大きな証明回路にして一度に証明しまう方式です。もう一つはプログラムの実行を小さなステップに分けて証明回路を繰り返し適用することで再帰的に証明する方式です。

前者をモノリシック（Monorithic）方式といい、後者をリカーシブ（Recursive）方式といいます。Monorithicで代表的なものはJolt/Lasso方式ですが、入門には難しすぎるので、比較的わかりやすいRecursiveのNova方式を本書では採用します。さらに、Novaの中でもわかりやすく今後の発展の基本となりそうなHyperNovaをベースに解説していきます。とくに、HyperNovaで使われる技術は、Joltでも使われるものが多く、学ぶメリットがあります。

::::{.note}
コラム: ゼロ知識証明の回路

ゼロ知識証明の中でもSNARKという分野では、計算をひとまとまりにした単位を回路と呼びます。面白いことにzkVMは、CPUを二進数のANDやORの論理回路から、有限体のADDやMULの証明回路で書き直していく作業になります。ある意味でzkVMは、論理演算を使わない別の世界のコンピューターをいえるかもしれません。
::::

::::{.note}
コラム: Novaの一族

Novaは高速なRecursive方式として、2021年ごろに登場しました。その後も改良が登場しましたが、それらの名前はオリジナルのNova（新星爆発）にちなんで付けられていきました。

最初に登場したのがSuperNova（超新星爆発）です。その後すぐにHyperNova(極超新星爆発)が提案され、さらにその後すぐに二つを組み合わせたSuperHyperNovaなんていうのも提案されかけました。

爆発のインフレーションはすぐに終わりましたが、現在でも〇〇Novaという名称や、Nebula（星雲）や ProtoStar（原始星）など宇宙にちなんだ名前が付けられています。

あなたのzkVMにも宇宙や星に関連する名前をつけてみるのも面白いかもしれません。
::::



### 本書の想定する開発環境

*執筆中*

### 著者について

*執筆中*

<br>

---

# ゼロ知識証明と計算圧縮

ゼロ知識証明というのは、その名の通り、「自分が持っている情報を明かさず、持っていることだけを証明する」技術の総称です。自分が隠したい情報を秘匿することが主な内容ですが、最近は計算量を圧縮することができる特性が注目されています。

たとえば、ブロックチェーン上で何かを計算させると、その計算量に応じてとにかく支払うコストが莫大にかかります。そこで、少しでも計算量と通信を減らしたいという動機が生まれ、この技術に注目と投資が集まるようになりました。これが近年急速にゼロ知識証明の研究が進んでいる理由です。


::::{.note}
コラム: SNARK

情報を秘匿しなくてもいいから計算が正しいことを証明したい、という需要があります。これを他のゼロ知識証明と区別するため、SNARK（スナーク）と名付けられました。

サイズの証明が短く (succinct) 、やり取りが一度きり (non-interactive) という意味です。さらに、ゼロ知識性がある場合はzkSNARKとZero Knowledgeの頭文字であるzkを先頭につけます。
::::

## 解と検証の計算

計算量を圧縮できるとはどういうことでしょうか。これは、問題を解く計算量と答えを検証する計算量が対応ではない、というありふれた問題として考えることができます。


たとえば、ソートを例に考えてみましょう。数字を順列に並び替える計算は、数列が順列であることを確かめるよりも多くの計算を必要とします。並び替え単純な方法は、最初の数字が右の数字よりも小さいかを比較して、大きければ入れ替える、という計算を全ての数字が満たすまで繰り返していきます。

一方で、数字が全て小さい順に並んでいるのを確かめるだけなら、左から順に数字を比較していくだけなので、数字の個数分の計算だけで済みます。つまり、100個の数字があるとすれば、ソートにはざっくり660回程度の計算が必要になりますが、確かめるには100回程度だけです。

このように、解く計算量よりも検証する計算の方が小さい、といった問題はありふれています。もし仮に、プログラムなどの計算をソートの解を求めることに置き換えることができるのなら、プログラムの計算が正しいかは、解が順列であるかを確かめるだけです。

ソートはあくまでも例えなので実際の証明には使いませんが、

1. 計算をとある問題の解を求めることへ変換する、 
2. その問題の解が正しいか検証してもらう、

の二つに分けることができます。


## シュワルツ・ジッペルの補題

ソートの例の代わりに、シュワルツ・ジッペルの補題（Schwartz-Zippel lemma）とSumcheck（合計チェック）いうものを使います。この二つによって、証明者が出した解を、検証者がより少ない計算で検証することができます。

ではいったい、どんな計算を減らすことができるのでしょうか？ それは、式の合計を求める計算です。

シュワルツ・ジッペルの補題とサムチェックを使うことで、証明者は式の合計がとある値になることを伝え、検証がそれが成り立つかを簡単に確かめることができるのです。

### 多項式とは

まずは、多項式が何かについておさらいしていきましょう。多項式とはその名の通り、項（係数 $\times$ 変数）が式中に1つ以上存在する式のことです。たとえば次のような式で、係数 $a,b,c$ と変数 $x,y,z$ からの項がいくつかあることがわかると思います。これらの式はこれ以上、項を減らすことはできません。

$$
\begin{aligned}
f(x) &= ax^2 + bx + c \\
g(x,y,x) &= ax + by + cz \\
\end{aligned}
$$

### 多項式の一致

シュワルツ・ジッペルの補題は、「 *二つの多項式の変数をランダムな値で評価したときに同じ結果になれば、二つが同じ多項式であると見なせる* 」といった定理です。中学や高校の数学の授業で、「二つの式が交わる点を求めよ」という問題を解いたことはないでしょうか？ 2つのグラフは、ほとんどの場所で重ならず、一点か二点だけでしか交わりません。

2つの多項式をグラフにプロットしたときに、交わる点は全体の中では驚くほど少ないということです。なので、全く異なる多項式が、完全にランダムな点で交わる確率は極僅かになります。この確率は適切に設定すれば実用上無視できる確率になります。どれくらいかというと、地球上のすべての砂粒の中から、私がまいた砂の1粒を1回で選び出す確率よりも低くなります。


*執筆中: 2つの式をプロットしたグラフを用意する。*

## 合計値での解の検証

特定の範囲では常に0になる多項式を見つけることができれば、検証者はその範囲の全ての値の合計も0であることを確かめれば良いのです。これにはサムチェックを使います。では、シュワルツ・ジッペルの補題はどこで出てくるかとういうと、サムチェックの中に出てきます。この辺りは後ほど解説しますので、身構えず読み進めてみてください。


::::{.note}
コラム: 計算量を表すオーダー

これを、オーダー（ $O$ ）という計算量を示す概念を導入して考えてみましょう。計算量は計算によって変化する個数 $N$ が計算の中でどれだけ影響するかで表します。もし、$N$ の数字があって全ての数字を一度だけ見る計算なら、$O(N)$ となります。全ての数字に対して、全ての数字を掛け合わせる計算だとすれば、1つに対して $N$ 回の計算が行われ、それが $N$ 回繰り返されるので、$O(N \times N)$ 、つまり、$O(N^2)$ になります。

ソートには最速でも $O(n\log{n})$ を必要とします。しかし、順列であることを確かめるだけだと、単純に考えても $O(n)$ だけです。

$N$ が小さい時にはそれほど違いを感じませんが、 $N$ が1,000や10,000 などになってくると計算回数にかなりの差が出てきます。

このように、大きな $N$ に対してどれだけ違うか、をみる指標なので、 $3 
\times N$ などの定数は無視して表記します。実際、大きな $N$ に対しては定数がかかっていてもそれほどの差は出ません。
::::

::::{.note}
コラム: 式を評価？

多項式に限らず、式の変数に値で代入して結果を求めることを「評価」するといいます。この単語は英語由来のevaluationを直訳したものなので、日本語にすると少し不思議な感じがします。evaluationには値付けという意味があるので、式の値を求める述語としては少し納得できます。

どちらにしろ、数学の世界では評価という単語が使われていますので、計算する、くらいの意味として覚えておいてください。

::::


<br>

---

# 計算の変換

証明したい計算、つまりプログラム、を多項式の形で表現できれば、どうやら証明できそうなことが分かってきました。ここからは、計算をどう多項式に変換していくかについて考えていきます。プログラムを含めた色々な種類の計算のフォーマットの全てから直接多項式に変換する方法を考えるのは、非常にコストが高い作業になります。そこで、このような問題を解決するのによく用いられる手法が中間表現です。多様なフォーマットから変換しやすく、目的にフォーマットにも変換しやすい表現を中間に挟むことで、開発のコストを下げるという考え方です。

## よく使われる計算の表現方法

プログラムを多項式に変換していく前ステップとして、まずは計算を $a \times b = c$ の連なりで表現していきます。ルールは、a,b,cの項の中にはいくら足し算を入れもていいですが、掛け算は1行につき $a \times b$ の一回だけですので、もう一度掛け算が必要な場合は次の行で行います。

たとえば、フィボナッチ数列なら次のようになります。aとbを足した結果がcとなり、次の行ではbとcが足されdとなっています。変数が同じなら、 $1\times c = (a + b)$ でも構いません。

$$
\begin{aligned}
(a + b) \times 1 &= c \\
(b + c) \times 1 &= d \\
(c + d) \times 1 &= e \\
(d + e) \times 1 &= f \\
\end{aligned}
$$

変数に値を入れてみると、次のようになるはずです。簡単ですので、合っているか手で計算してみてください。この $a$ から $f$ の値が計算の解となるわけです。

$$
a = 1, b = 2, c = 3,d = 5,e = 8,f = 13
$$

$ax^3 + b x^2 + cx + d = e$ なら次のようになります。 $x^2$ と $x^3$ はそれ自体が $x$ の掛け算なので、$v,w$ に割り当ててあげて、$ax^3$ などは中間結果として $\alpha$ と置いてあげます。

$$
\begin{aligned}
x \times x &= v \\
x \times v &= w \\
a \times w &= \alpha \\
b \times v &= \beta \\
c \times x &= \gamma \\
(\alpha + \beta + \gamma + d) \times 1 &= e
\end{aligned}
$$

この表現方法でプログラムのすべてを書き出すのは少々骨が折れる作業ですが、全くできないという程でもありません。また、変換するツールなどもあるので、それらを使えば好きなプログラムをこの形式に直すこともできます。先ほど説明した専用言語やコンパイラのことです。

全てのプログラムをこの形式に変換できるわけではありませんが、表現が難しいものは別の技術を使ってカバーします。

::::{.note}
コラム: ルックアップ

*執筆中, ビット演算、浮動小数点数, 行列の掛け算*

::::

## 行列式へ変換

さて、プログラムを単純な形で表現することができましたが、これだけでは不十分です。なぜなら、$a,b,c,d,v,w,x,..$ などの変数は、文字的に同じ変数と見なしているだけで、それらが同じであるかを制約するものは何もないからです。

このような変数の使い回しを式で表現するには、行列の掛け算を使います。まずは、行列について少し触れます。

### 行列とは

*執筆中*

### 行列で変数の切り替え

用意するのは、要素が $0,1$ で構成された $m \times n$ 行列 $A$ と、すべての変数が列挙された $n \times 1$ 行列 $Z$ です。すると、次のように、$Z$ から選ばれた変数の合計が結果となります。

$$
\begin{aligned}
A \cdot Z &=
\begin{bmatrix}
1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&=
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix} \\
\end{aligned}
$$

左の行列の中で、1になっている列番目が、対応する $Z$ の行番目になっていることがわかります。1行目では [1 1 0 0 ...] となっているので、 $Z$ の1行目と2行目の $a,b$ が選択され、行列の掛け算の規則により、それらが足された値が結果の行列の1行目の要素となっています。

$$
(1 \cdot a) + (1 \cdot b) + (0 \cdot c) + (0 \cdot d) + (0 \cdot e) + (0 \cdot f) + (0 \cdot 0) + (0 \cdot 1)
$$

これは、先ほどのフィボナッチ数列の $a \times b = c$ のうち、$a$ のすべての項の集合になっていることがわかります。 $b,c$ についても、次のように変数を選び、その和をとります。ただし、フィボナッチ数列では $a$ 以外では和を取らないので、ただ変数を選択しただけになっています。

$$
\begin{aligned}
B \cdot Z &=
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&=
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}\\
\\
C \cdot Z &=
\begin{bmatrix}
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
0 \\
1 \\
\end{bmatrix}
&=
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\
\end{aligned} \\
$$

最終的に、これを行列の式で表すと、次のようになります。 $\circ$ 記号は アダマール積（Hadamard Product）といって、重なり合う要素の掛け算だけをする演算記号です。普通の行列の掛け算は $\cdot$ 記号で表されます。

$$
\begin{aligned}
A \cdot Z \quad \circ \quad B \cdot Z  \quad &= \quad C \cdot Z  \\
\\
\begin{bmatrix}
a + b \\
b + c \\
c + d \\
d + e \\
\end{bmatrix}
\quad
\circ
\quad
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
\end{bmatrix}
\quad
&=
\quad
\begin{bmatrix}
c \\
d \\
e \\
f \\
\end{bmatrix} \\
\end{aligned}
$$

行列を使うことで、どの変数をどう使うかを表現することができました。この表現方法はR1CS（Rank-1 Constrain System）と呼ばれます。

## 多項式への変換

行列式のままでは、掛け算などの手順が複雑なので、これを一旦次のような式に変形します。 $\sum$ は $i$ を0からN-1まで順番にあげていき、その和を取る演算記号です。上の行列式の $0$ 行目の計算と一致していることがわかると思います。

$$
\sum_{i=0}^{N-1}{A[0,i] \cdot Z[i]} \quad \cdot \quad \sum_{i=0}^{N-1}{B[0,i] \cdot Z[i]} \quad = \quad \sum_{i=0}^{N-1}{C[0,i] \cdot Z[i]}
$$

上の式では、$A[X,Y]$ でX行Y列の要素を取り出していますが、これは多項式の一部ではありません。なので、変数 $x$ によって同じように取り出せなくてはなりません。

$$
\begin{aligned}
&f(x) = \sum_{i=0}^{N-1}{A(x,i) \cdot Z(i)} \quad \cdot \quad \sum_{i=0}^{N-1}{B(x,i) \cdot Z(i)} \quad - \quad \sum_{i=0}^{N-1}{C(x,i) \cdot Z(i)} = 0, \\
&\{x | 0 \le x \lt M \}
\end{aligned}
$$

$A(x,y)$ などをどう作るかは置いておいて、$f(x)=0$ の形に近くなってきました。どんな $x$ とはいかずとも、0からM-1の区間なら0になります。

### 行列の要素を取り出す多項式を考える。

$A(x,y)$ を作るにはどうしたらいいでしょうか？　まずは変数が1つの$Z(x)$ から考えてみることにします。

$[a,b,c,d,e,f,0,1]$ からn番目の要素を取り出すのは、先ほどの $\{0,1\}$ の行列で使ったテクニックを使います。つまり、取り出したい要素だけ1にして、それ以外は0にするという方法です。

$$
\begin{aligned}
Z(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8) &= (x_1 \cdot a) + (x_2 \cdot b) \\
&+ (x_3 \cdot c) + (x_4 \cdot d) \\
&+ (x_5 \cdot e) + (x_6 \cdot f) \\
&+ (x_7 \cdot 0) + (x_8 \cdot 1)
\end{aligned}
$$

しかし、これでは変数の数が多い上に、2つ以上を選択してその合計値を取ってくることが出来てしまします。そこで、$Z$ への入力は $n$ を二進数で渡せるようにします。これだと、要素が8個ならば3つの変数だけでよく、さらに同時に1つの要素しか選択できません。

用意するのは、2つの二進数が一致すれば $1$ , 異なれば $0$ になる多項式です。これは次のように作ることができます。 $\prod$ は $i$ を増やしていって、その積をとる演算記号です。 $\sum$ の掛け算バージョンだと思ってください。

$$
eq((x_1, x_2, x_3), (y_1, y_2, y_3)) = \prod_{i=1}^3{(1-x_i)(1-y_i) + x_i y_i}
$$

3bitはここに書くのは長いので2bitにしますが、展開するとこのようになります。ビットが違う項はゼロになるので、一つでもゼロになれば掛け算によって結果もゼロになります。

$$
\begin{aligned}
eq((1,0), (1,0)) = \{(1-1)(1-1) + 1 \cdot 1 \} \cdot   \{(1-0)(1-0) + 0 \cdot 0 \} &= 1, \\
eq((0,1), (1,1)) = \{(1-0)(1-1) + 0 \cdot 1 \} \cdot   \{(1-1)(1-1) + 1 \cdot 1 \} &= 0, \\
\end{aligned}
$$

ということで、$eq$ を使うと $Z$ は次のように書くことができます。 $X$ は $(x_1, x_2, x_3)$ のことです。

$$
\begin{aligned}
Z(X) &= a \cdot eq(X, (0,0,0)) + b \cdot eq(X, (0,0,1)) \\
&+ c \cdot eq(X, (0,1,0)) + d \cdot eq(X, (0,1,1)) \\
&+ e \cdot eq(X, (1,0,0)) + f \cdot eq(X, (1,0,1)) \\
&+ 0 \cdot eq(X, (1,1,0)) + 1 \cdot eq(X, (1,1,1))
\end{aligned}
$$

これを定義にしてみましょう。 少し複雑なので順を追って説明していきます。 $y\in \{0,1\}^{\log N}$ は言葉にするなら、「Nをビットで表したときのすべてのパターン」です。$Z[X]$ は定数なので式を展開したときには実際の値が入ります。つまりこの式は、 $X$ と $y$ のビットが一致するとき、それに対応する $Z$ の要素を取り出す、ということになります。

$$
Z(X) = \sum_{y\in \{0,1\}^{\log N}}{Z[X] \cdot eq(X, y)}
$$

例えば、このようになります。

$$
\begin{aligned}
Z((0,0,0)) &= a, \\
Z((0,0,1)) &= b, \\
Z((0,1,0)) &= c, \\
\end{aligned}
$$


$A,B,C$ も同じように定義することができます。ただし、行と列の二つを指定する必要があるので、それぞれの要素に対して $eq$ を二つかけてあげます。

$$
A(X_1, X_2) = \sum_{y_1\in \{0,1\}^{\log M}} \sum_{y_2\in \{0,1\}^{\log N}}{A[X_1, X_2] \cdot eq(X_1, y_1) \cdot eq(X_2, y_2)}
$$


$eq$ をベースに作った多項式は嬉しい性質があるので、他と区別できるようこれ以降は $\tilde{Z}(\cdot),\tilde{A}(\cdot),\tilde{B}(\cdot),\tilde{C}(\cdot)$ と表記しておきます。

### 多項式を1つにまとめる。

定義した多項式を一つにまとめます。

$$
\begin{aligned}
G(X) &= \sum_{y\in \{0,1\}^{\log N}} \tilde{A}(X, y) \cdot \tilde{Z}(y) 
\cdot \sum_{y\in \{0,1\}^{\log N}} \tilde{B}(X, y) \cdot \tilde{Z}(y)
- \sum_{y\in \{0,1\}^{\log N}} \tilde{C}(X, y) \cdot \tilde{Z}(y) \\
\\
&X \in \{0,1\}^{\log M}
\end{aligned}
$$

この $G$ は $X$ の全てのパターンで $G(X) = 0$ が成り立つはずです。もしどれか一つでも $0$ でなければ、それは不正な操作が行われ、 $a \times b = c$ のどこかが間違っているということになります。例えば、 $3 \times 2 = 5$ のような式が含まれているということです。

行列の行数 $M = 4$ なら変数は2つで、次のようになります。

$$
G((0,0)) = G((0,1)) = G((1,0)) = G((1,1)) = 0
$$

### 打消して合計がゼロになる。

全て $0$ になるのなら、合計も $0$ であるはずなので、一つの式にまとめることができます。
$$
\sum_{y\in \{0,1\}^{\log M}} G(y) = 0
$$

しかし、例えば、$G((0,0)) = 1, G((0,1)) = -1$ だとすると、お互いを打ち消してしまい、合計として $0$ になることを防げません。

そこで、$G$ にランダムな係数をかけて、打消し合う可能性を小さくするという発想が考えられます。

$$
\begin{aligned}
&\sum_{y\in \{0,1\}^{\log M}} r_i \cdot G(y) \\
\\
&= r_1 \cdot G((0,0)) + r_2 \cdot G((0,1)) + r_3 \cdot G((1,0)) + r_4 \cdot G((1,1)) \\
&= 1 \cdot r_1 + (-1) \cdot r_2 + 0 \cdot r_3 + 0 \cdot r_4\\
&\ne 0
\end{aligned}
$$

だだし、これでは変数がなく、多項式ではなくなってしまうので、次のようにしてあげることで、多項式のままにすることができます。 

$$
\tilde{Q}(\beta) = \sum_{y\in \{0,1\}^{\log M}} G(y) \cdot eq(y, \beta) = 0
$$
式を見ると、$G$ にかかるランダムな係数が、$eq(y, \beta)$ によって変化していくことがわかります。さらに、　ランダムな値 $\beta$ が $\{0,1\}^s$ でない限りは、 $eq$ がゼロになることはありません。なので、 $eq$ はランダムな変数によって係数が変わり、さらにそれ自体が0にならない、という嬉しい性質があるのです。

例えば、$\beta = (11, 22)$ ならば、次のように展開できます。

$$
\begin{aligned}
\tilde{Q}((11, 22)) &= G((0,0)) \cdot (1-11) \cdot (1-22) \\
&+ G((0,1)) \cdot  (1-11) \cdot 22 \\
&+ G((1,0)) \cdot  11 \cdot (1-22) \\
&+ G((1,1)) \cdot  11\cdot 22 \\
\end{aligned}
$$

### 検証コストが減ってない。

$\tilde{Q}$ を展開してみるとわかるのですが、$G$ がゼロになるので、$f(x) = 0 \cdot x_1 + 0 \cdot x_2$ のような、全ての項の係数が $0$ となるゼロ多項式となってしまいます。これでは、この多項式を検証者が渡されても何を検証していいか分からず、式の正当性を確かめられません。 $G$ が 本当に $0$ であるかを確かめてもうらうには、$G$ の変数を残さなくてはいけないのです。

そこで、$Q(\beta)$ から合計する前の項を取り出し、 $g(X)$ とします。検証者には、この $g$ が  $\{0,1\}^s$ の全てで $0$ になることを確かめてもらうことで、計算が正しかったと検証してもらいます。

$$
g(X) =  G(X) \cdot eq(X, \beta)
$$


検証者に直接 $g(X)$ を渡して、全パターンを試してもらうこともできますが、それでは計算が減るどころか少し増えてしまいます。

ここで使えるのが、sumcheck protocol です。検証者が全パターンを試すよりも少ないコストで、全てのパターンが $0$ であることを証明することができす。

<br>

---

# サムチェック・プロトコル

いよいよ登場しました、Sumcheck Protocol です。 仕組みを言葉で表現するならば、「変数が1つの多項式に分解し、それぞれが同じ多変数多項式がベースであることをランダムな点で検証してもらう。」です。


多変数多項式とは、 $f(x,y,z) = ax + by + cz$ のような変数が複数ある式で、単変数多項式とは  $h(x) = ax + b$ のような変数が一つだけの式の事です。では、なぜ変数ごとに式を分けると計算量が減るかを考えてみましょう。

単純に考えると、3変数多項式なら、$f$ の中の3つの変数の評価を8パターンで試すので、$3 \times 2^3 = 24$ の計算が必要になります。
一方で、3変数多項式を3つの単変数多項式に分解すると、変数を評価は同じく8パターンですが、式中の変数は1つだけなので、 $1 \times 2^3 = 8$ となります。

Sumcheck Protocol では1つの式ごとに3回の評価が必要なだけなので、 $O(N)$ ですが、全パターンを評価するのは $O(N \cdot 2^N)$ となります。

このように、検証者の評価の回数を減らしつつ、適切に元の多変数多項式が分けられているのかを証明するのがこの Sumcheck Protocolの肝なのです。

ではまず、単変数への変換方法を考えます。ここでは $g(X)$ を取り扱いたいので、ひとまず、 $X = (x_1, x_2)$ としておきます。
検証者には次の3つの多項式と使用したランダムな3つの値 $r1, \beta_1, \beta_2$ を渡します。この $r1$ は検証者から最初にもらったり、改竄できない形で証明者が生成したりします。

$$
\begin{aligned}
g(X) &=  G(X) \cdot eq(X, (\beta_1, \beta_2)), \\
g_1(x_1) &= \sum_{y \in \{0,1\}}{g((x_1, y))}, \\
g_2(x_2) &= g((r_1, x_2)), \\
\end{aligned}
$$

検証者は、$g(X)$ が全てのパターンで $0$ になることを $g_1, g_2$ を使って確かめていきます。まず、$g_1(x)$ を使って、$G(X)$ がどのパターンでも $0$ であるという主張を確かめます。この時点では $g_1(x)$ が　$G(X)$ を元に作られているかはまだ検証できていませんが、ひとまず $G(X)$ がゼロになりそうなことは分かりました。

$$
g_1(0) = g_1(1) = 0
$$

なので検証者は、本当に $g_1(x)$ が $G(X)$ の $x_2$ を $0$ と $1$ で評価した多項式であるかを確かめなければなりません。方針は、シュワルツ・ジッペルの補題 を使って、ランダムな点で評価して同じ多項式は同じと見なせる、という性質を使います。つまり、$g_1(x)$ と $G(X)$ を $x_1,x_2$ を $r_1,r_2$ で評価してその結果を比べるということです。

しかし、$g_1(x)$ の内部の $x_2$ はすでに $0,1$ で評価されてしまっているので、$g_2(x)$ を代わりに使います。まずは、$g_1(x)$ と $g_2(x)$ が同じ多項式であるかを確かめましょう。ちなみに、この時点で $g_1, g_2$ の内部で本当に $g$ が使われているか分からないので、$g$ の代わりに $s, s'$ をおいておきます。

$$
\begin{aligned}
g_1(r_1) &= g_2(0) + g_2(1) \\
\\
\sum_{y \in \{0,1\}}{s((r_1, y))} &= s'((r_1, 0)) + s'((r_1, 1))
\end{aligned}
$$

$g_1, g_2$ がどうやら同じ多項式 $s$ を元に作られたということは確かめられました。そして、$g_2$ を使うことで、$G(X)$ と同じ多項式であるかも確かめることができます。これには、 $G$ を $r_1, r_2$ で評価し、その結果を $g_2$ を $r_2$ で評価した結果と比べます。すると、$g_2$ の内部にある $x_1$ は既に $r_1$ で評価されているので、同じランダムな点で二つの多項式を評価し比較することができるのです。

$$
\begin{aligned}
G((r_1, r_2))  &= g_2(r_2) \\
\\
&= s((r_1, r_2)) \\
\end{aligned}
$$

二つが同じ値になるなら、$g_1$ の内部で使われている多項式 $s$ は $G$ と同じなので、$g_1(0) = g_1(1) = 0$ によって、全てのパターンで $G$ がゼロであることも検証できました。

ここまでは $X$ の変数が2つでしたが、3つ以上の場合には 

$$
\begin{aligned}
g_2(r2) &= g_3(0) + g_3(1), \\
g_3(r3) &=  g_4(0) + g_4(1), \\
...
\end{aligned}
$$ 

と検証しいき、$G((r_1, r_2,.., r_n)) = g_n(r_n)$ となることを確かめます。

## 13. ランダムな値をどうするか。

## 14. 渡された多項式が期待しているものか。

--------
(*) 重要な定理を導入すると、「非零多項式には根（ゼロ点）が多くない」を利用することができる。